<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Архітектура комп'ютерів</title>
	<link href="../style/style.css" rel="stylesheet">
	<link rel="shortcut icon" href="../img/favicon.ico" />
	<script src="../js/jquery-3.2.1.min.js"></script>
	<script src="../js/JavaScript.js" type="text/javascript" ></script>
</head>
<body class="body">
	<div class="wrapper clearfix">
		<header class="header">
			<nav class="menu">
				<ul>
					<li><a href="CPU.html">Енциклопедія</a></li>
					<li><a href="index_CPU.html">Побудова ЦП</a></li>
					<li><a href="motherboard.html">Мат. плата</a></li>
					<li><a href="x86.html">X86</a></li>
					<li><a href="index_PG_CPU.html">Програмна модель ЦП</a></li>
				</ul>
				<form>
					<input type="text" id="text-to-find" value="">
					<button type="submit" onclick="javascript: FindOnPage('text-to-find'); return false;" value="Пошук"></button>
				</form>
			</nav>
		</header>
		<main class="content">
			<div class="pad">
				<div class="in-cont-nav">
					<p>Зміст</p>
					<ul>
						<li><a href="#1">1.Загальні положення і обчислювальні парадигми</a></li>
						<li><a href="#2">2.Команди x86 і їх набори</a></li>
						<li><a href="#3">3.Загальний пристрій конвеєра</a></li>
						<li><a href="#4">4.Стадії конвеєра</a></li>
						<li><a href="#5">5.Блоки процесора</a></li>
						<li><a href="#6">6.Підсистема пам'яті</a></li>
						<li><a href="#7">7.Фізична реалізація</a></li>
					</ul>
				</div>
			</div>	
			<div class="main-text">
				<h1>Енциклопедія процесорних термінів</h1>
				<h3><a name="1"></a>Загальні положення і обчислювальні парадигми</h3>
				<p><a name="processor"></a><b>processor (обробник), процесор</b> - частина комп'ютера, яка оброблює дані. Керується програмою або потоком - послідовністю закодованих <a href="#instruction">команд</a>. Фізично представляє собою одну <a href="#chip">мікросхему</a>. Працює на певній частоті, що означає кількість тактів за секунду. За кожний такт процесор робить деяку частину роботи. За замовучуванням под процесором розуміється <a href="#CPU">центральний процесор</a>.</p>
				<p><a name="CPU"></a><b>CPU (central processing unit: «центральный блок обробки), ЦП (центральний процесор)</b> - головний і обов'язково присутній <a href="#processor">процесор</a> комп'ютера, що обробляє дані будь-якого виду (на відміну від <a href="#coprocessor">сопроцесорів</a>).</p>
				<p><a name="coprocessor"></a><b>coprocessor, сопроцесор</b> - cпеціалізований <a href="#processor">процесор</a> (наприклад, дійсний або периферійний), що обробляє дані тільки якогось одного виду, але швидше, ніж це зміг би зробити <a href="#CPU">ЦП</a>, за рахунок оптимізованого пристрою. Може бути як окремої <a href="#chip">мікросхемою</a>, так і частиною ЦП.</p>
				<p><a name="core"></a><b>core, ядро</b> - в одноядерних ЦП: обчислювальна частина процесора, що залишається після вирахування допоміжних структур (контролерів шин, <a href="#cache">кешей</a> і ін.). У багатоядерних ЦП: набір обробних блоків і суміжних з ними кешей, мінімально необхідних для виконання будь-яких <a href="#instruction">команд</a> і наявний в декількох примірниках. Багатоядерні ЦП можуть мати багаторівневий поділ ресурсів: наприклад, ядра з окремими кешами <a href="#L1">L1</a> можуть попарно об'єднуватися, маючи в кожній парі загальний кеш <a href="#L2">L2</a>, а пари об'єднуються в процесор із загальним кешем <a href="#L3">L3</a> і іншим блоками. AMD в нових <a href="#microarchitecture">мікроархітектурах</a> використовує визначення ядра, виконуючого лише <a href="#operation">операції</a> (не команди) загального призначення.</p>
				<p><a name="SMP"></a><b>SMP (symmetric multiprocessing: симетрична багатопроцесорність)</b>- одночасна присутність і робота в комп'ютері кількох однакових <a href="#processor">процесорів</a> і/або <a href="#core">ядер</a>.</p>
				<p><a name="uncore"></a><b>uncore («позаядро»)</b>термін Intel для позначення частини ЦП за межами <a href="#x86">x86</a>-<a href="#core">ядра</a> або ядер. Ресурси «позаядра» (<a href="#GPU">ГП</a>, кеш <a href="#L3">L3</a> і <a href="#system-agent">системний агент</a>) динамічно розділяються між ядрами в залежності від потреби.</p>
				<p><a name="system-agent"></a><b>system agent (системний агент)</b>термін Intel для позначення частини ЦП за межами всіх ядер (включаючи спеціалізовані - наприклад, <a href="#GPU">графічне</a>) і кеша <a href="#L3">L3</a>. Є частиною позаядра.</p>
				<p><a name="word"></a><b>word, слово</b> - в загальному випадку - послідовність інформації довжиною 2N байт, де ціле N>0. За вмістом може бути даними, адресою або <a href="#instruction">командою</a>. Іноді використовується як міра розрядності (півслова, подвійне слово тощо) поряд з бітами і байтами. В <a href="#ISA">архітектурі</a> <a href="#x86">x86</a> позначає 2-байтовое <a href="#integer">ціле</a> дане.</p>
				<p><a name="instruction"></a><b>instruction, інструкція, команда</b> — елементарна частина програми процесора. Команда задає <a href="#operation">операцію(ї)</a> над даними і/або адресами. Найбільш часто викорисовувані команди поділяються на такі види:</p>
				<ul class="ul"><li>копіювання *;</li><li>перетворення типу;</li><li>перестановка елементів* (тільки для </a href="#SIMD">векторних</a>);</li><li>арифметика;</li><li>логіка* і зрушення*;</li><li><a href="#jmp">переходи</a>.</li></ul>
				<p>Зазначені зірочками команди є інваріантними за даними - вони реалізують свою дію за однаковим алгоритмом незалежно від типу <a href="#operand">операндів</a>. Команди, що змінюють вміст даних, є обчислювальними: найчастіше зустрічається проста арифметика і логіка, потім <a href="#MUL">множення</a> і <a href="#shifter">зрушення</a> і, набагато рідше, - <a href="#DIV">поділ</a> та перетворення.</p>
				<p><a name="conditional"></a><b>conditional, умовна</b>- <a href="#instruction">команда</a> або <a href="#operation">операція</a>, що виконується при збігу необхідної умови зі станом прапорів.</p>
				<p><a name="operation"></a><b>operation, операція</b> - задаваєма <a href="#instruction">командою</a> дія над своїми аргументами - даними або (рідше) адресою. Одна команда може задати кілька дій.</p>
				<p><a name="operand"></a><b>operand, операнд</b> - параметр, що позначає дані для <a href="#operation">операції</a> або місце, де вони знаходяться. У команді може бути від нуля до декількох операндів, більшість з яких явні (тобто вказані в команді), але деякі (приховані) використовуються за замовчуванням. Число навіть явних операндів не завжди збігається з числом аргументів виконуваної операції. Види операндів:</p>
				<table class="table-mpt">
					<tr class="grey">
						<td class="purple">За характером доступу</td>
						<td>Джерело (зберігає аргумент)</td>
						<td>Приймач (отримує результат)</td>
						<td>Модифіканд (джерело до операції і приймач після)</td>
					</tr>
					<tr class="lilak">
						<td class="purple">За типом</td>
						<td><a href="#register">Регістр</a> (вказано його номер)</td>
						<td>Пам'ять (одно- або мультибайтове значення за вказаною адресою)</td>
						<td>Константа (безпосереднє значення, записане в самій команді, може бути тільки джерелом)</td>
					</tr>
				</table>
				<p><a name="non-destructive"></a><b>non-destructive, неруйнівний</b> - формат <a href="#operand">операндів</a> команди, при якому її результат не зобов'язаний перезаписувати будь-який з аргументів, інакше формат називається руйнівним. Щоб команда була неруйнуючою, приймач повинен бути окремим від усіх джерел (тобто не повинно бути модіфікандів, крім випадків явної вказівки однакового приймача і джерела). Наприклад, для елементарного складання це потребує трьох операндів - приймача і двох джерел. У випадку з двома операндами сума перезапише одну з складових.</p>
				<p><a name="integer"></a><b>integer, цілий, цілочисельний</b> — відноситься до цілих чисел. Має розрядність 1, 2, 4 и 8 байтів. Як правило, к ним також причислюють логічний тип данних, що описує набір бітів. Обробка цілих даних простіше і швидше, ніж <a href="#float">дійсних</a>.</p>
				<p><a name="float"></a><b>float («плаваючий»), FP (floating point: плаваюча точка), дійсний</b> - відноситься до дійсних чисел (точніше, до їх раціональної підмножини з плаваючою комою). Має точності <a href="#HP">HP, SP, DP і EP</a>. Обробка <a href="#integer">дісних</a> чисел важче і довше, ніж цілих.</p>
				<p><a name="register"></a><b>register, регістр</b> - осередок, що зберігає одне або кілька значень певної розрядності і типу (наприклад, <a href="#integer">цілий</a> <a href="#SIMD">векторний</a>). Є найбільш частоіспользуемих типом операнда. Кілька однотипних регістрів об'єднані в <a href="#RF">регістровий файл</a>.</p>
				<p><a name="GPR"></a><b>GPR (general purpose register), РЗП (регістр загального призначення)</b> - регістр для скалярних <a href="#integer">цілих</a> даних або адрес, який використовується для найбільш частих команд.</p>
				<p><a name="ISA"></a><b>ISA (instruction set architecture: архітектура набору команд)</b> - опис процесора як математичної моделі, якою він представляється програмісту. Складається з описів всіх виконуваних команд, наявних регістрів, режимів та ін. cтруктур і станів, доступних програмісту. Грунтується на одній або більше <a href="#paradigm">парадигмах</a>. Без уточнення термін «архітектура» часто позначає <a href="#microarchitecture">микроархитектуру</a>.</p>
				<p><a name="microarchitecture"></a><b>microarchitecture, мікроархітектура</b> - реалізація <a href="#ISA">ISA</a> у вигляді блок-схеми процесора, кожен блок якої виконує відокремлену роль або функцію і складається з масивів логічних вентилів ( «екземплярів») і пов'язує їх лінії. Для кожної ISA, як правило, є кілька мікроархітектури, що відрізняються швидкістю виконання окремих команд і всієї програми, складністю і ціною одержуваного процесора, споживаною енергією на кожну операцію тощо. Більшість описуваних мікроархітектури блоків і станів «прозорі» для програміста (т. к. не вказані в ISA) і потрібні для автоматичного поліпшення будь-якої чисельної характеристики - швидкості, надійності, споживання енергії і т. д. Часто позначається терміном <a href="#architecture">«архітектура»</a>. </p>
				<p><a name="paradigm"></a><b>paradigm, парадигма</b> - тут: сукупність основоположних правил і понять, на основі яких будується конкретна <a href="#ISA">програмна архітектура</a> або <a href="#microarchitecture">мікроархітектура</a>. Деякі парадигми взаємовиключні, інші можуть поєднуватися.</p>
				<p><a name="load/store"></a><b>load / store (завантаження / збереження - синоніми читання і запису)</b> - парадигма, при якій команди обробки працюють тільки з <a href="#register">регістрами</a>, а завантаження констант і обмін даних між процесором і пам'яттю здійснюється окремими командами і теж через регістри. Це дозволяє сильно спростити пристрій і знизити собівартість процесора, але ускладнює програмування, уповільнює швидкість виконання за такт і подовжує програму. Більшість сучасних архітектур не використовують парадигму load / store, допускаючи для більшості або всіх команд обробку даних, що знаходяться і в регістрах, і в пам'яті, і в самій команді. </p>
				<p><a name="RISC"></a><b>RISC (reduced instruction set computer: обчислювач зі скороченим набором команд) </b> - парадигма архітектури, що є максимально зручною для фізичної реалізації (на противагу <a href="#CISC">CISC</a>): процесор має невелике число команд (як правило, до 200), велика частина яких виконує по одній простій дії (як правило, не складніше за множення) зі значними обмеженнями по розрядності, розташуванню і типу аргументів (зокрема, використовується парадигма <a href="#load/store">load / store)</a>. За рахунок простоти майже кожна команда виконується за одну дію, тому процесору не потрібен <a href="#microcode">мікрокод</a>. Найчастіше команди мають однакову довжину (як правило, 4 байта) і <a href="#non-destructive">неруйнівне</a> кодування </a href="#operand">операндів</a>.</p>
				<p><a name="CISC"></a><b>CISC (complex instruction set computer: обчислювач зі складним набором команд) </b> - парадигма архітектури, що є максимально зручною для ефективного (по числу </a href="#OPC">OPC</a>) програмування (на противагу RISC): процесор має велике число команд (сотні), які виконують в т. ч. складні дії з аргументами різної розрядності, розташування і типу. Складні команди виконуються як послідовність простих, для цього процесору потрібен <a href="#ID">декодер</a>. Команди мають змінну довжину; в порівнянні з RISC-ЦП код виходить більш компактним як по числу команд, так і по загальній довжині. За рахунок різноманітності і складності команд, меншого числа архітектурних регістрів і (часто) <a href="#destructive">руйнуючого</a> формату операндів програмування CISC-ЦП для компілятора складніше, ніж RISC-ЦП, але для людини-програміста це не обов'язково. CISC-ЦП для досягнення продуктивності RISC-ЦП на однаковій частоті повинен бути складніше. </p>
				<p><a name="SIMD"></a><b>SIMD (single instruction, multiple data: одна команда - багато даних), векторність </b> - парадигма паралелізму на рівні даних: крім скалярних, є векторні команди для обробки аргументів-векторів, які об'єднують кілька окремих скалярних значень. Результат векторної команди - найчастіше також вектор. Застосовується у всіх сучасних архітектурах для зручної реалізації високошвидкісної обробки, коли над великим об'ємом даних потрібно зробити одну дію. SIMD також має на увазі наявність команд </a href="#shuffle">тасування</a> елементів вектора без зміни їх вмісту.</p>
				<p><a name="EPIC"></a><b>EPIC (explicitly parallel instruction computing: обчислення з явним паралелізмом команд) </b> - парадигма, яка спрощує <a href="#superscalar">суперскалярну</a> мікроархитектуру за рахунок явної вказівки «зв'язок» команд, які можуть одночасно відправитися на виконання при готовності необхідних даних. Застосовується тільки до <a href="#RISC">RISC</a>-архітектур, хоча теоретично може бути застосована і до <a href="#CISC">CISC</a>. Для обробки даних загального призначення не підходить із-за відносно великого розміру коду та складності ефективного програмування і виконання на будь-якому алгоритмі, тому для ЦП малопридатна, але застосовується в деяких <a href="#DSP">DSP</a> і <a href="#GPU">GPU</a>.</p>
				<p><a name="DSP"></a><b>DSP (digital signal processor: цифровий обробник сигналів), цифровий сигнальний процесор </b> - <a href="#coprocessor">співпроцесор</a>, оптимізований для обробки потоку даних, в т. ч. в реальному часі. Іноді вбудовується в </a href="#SoC">SoC</a>.</p>
				<p><a name="GPU"></a><b>GPU (graphics processing unit: блок обробки графіки), графічний процесор (ГП) </b> - <a href="#coprocessor">співпроцесор</a>, оптимізований для обробки графіки в реальному часі і деяких <a href="#GPGPU">неграфічних завдань</a>. ГП іноді вбудовується в <a href="#chip">мікросхему</a> ЦП. </p>
				<p><a name="GPGPU"></a><b>GPGPU (general purpose GPU: обчислення загального призначення на ГП) </b> - програми обробки неграфічних даних, алгоритми яких зручні для ефективного виконання не тільки на ЦП, але і на ГП. Складання таких алгоритмів складніше через великі обмеження ГП в порівнянні з ЦП. </p>
				<p><a name="APU"></a><b>APU (accelerated processing unit: блок прискореної обробки) </b> - термін AMD для позначення процесора з <a href="#core">ядром</a> або ядрами загального призначення архітектури <a href="#x86">x86</a> і вбудованим <a href="#GPU">ГП</a>, архітектура якого допускає відносно просту обробку неграфічних даних за допомогою <a href="#GPGPU">GPGPU</a>.</p>
				<p><a name="SoC"></a><b>SoC (system on chip: система на чіпі) </b> - мікросхема, на єдиному або основному <a href="#die">кристалі</a> якого знаходяться ядро або ядра ЦП, <a href="#coprocessor">сопроцесори</a> і / або DSP і контролери пам'яті і введення-виведення. (Решта кристалів в разі їх присутності є пам'яттю.) Використовується замість декількох окремих <a href="#chip">мікросхем</a> зі схожою сукупною функціональністю для зменшення маси, розмірів, складності монтажу, споживання енергії і ціни кінцевого пристрою. </p>
				<p><a name="embedded"></a><b>embedded, вбудований </b> - відноситься до комп'ютерів і мікросхем, керуючими необчислювальною апаратурою (і часто фізично вбудовані в неї) і/або збирає дані з датчиків. Вбудований комп'ютер може мати людино-машинний інтерфейс, але з користувачем він спілкується набагато рідше, ніж з іншими пристроями. Для таких комп'ютерів потрібна висока надійність в широкому спектрі фізичних впливів (в т. ч. жорстких), часто на шкоду іншим характеристикам (наприклад, швидкості). </p>
				<p><a name="ARM"></a><b>ARM</b> - <a href="#RISC">RISC</a>-архітектура, перша за поширеністю в світі (друга - <a href="#x86">x86</a>). Застосовується в мобільних комп'ютерах і похідних від них пристроях (комунікаторах, телефонах, планшетах і ін.) і в більшості <a href="#embedded">вбудованих</a> систем. Має <a href="#non-destructive">неруйнівний</a> формат операндів. Число доступних регістрів в <a href="#RF">РФ</a> - 16. </p>
				<p><a name="VM"></a><b>VM (virtual memory: віртуальна пам'ять) </b> - технологія, що дозволяє кожній виконуваній програмі в багатозадачному середовищі використовувати окремий безперервний адресний простір, причому більшого розміру, ніж є фізичної оперативної пам'яті, а також реалізувати захищене виконання з ізоляцією програм і їх даних один від одного. Віртуальна пам'ять фізично розміщується в ОЗУ і файлі підкачки (своп-файлі) на масовому носії. У режимі роботи з віртуальною пам'яттю програми оперують віртуальними адресами. </p>
				<p><a name="VA"></a><b>VA (virtual address: віртуальна адреса) </b> — адреса для <a href="#VM">віртуальної пам'яті</a>, який до використання необхідно перерахувати (транслювати) в фізичну адресу в блоках <a href="#TLB">TLB</a> і <a href="#PMH">PMH</a>. Кожен віртуальний адрес потрапляє в яку-небудь <a href="#page">сторінку</a>, яка описується дескриптором ( «описувачем») розміром в 4 (в 32-бітному режимі ЦП) або 8 (в 64-бітному) байт, що містить фізичну адресу, тип і права доступу сторінки або їх групи. 512 або 1024 дескриптора формують таблицю трансляції, а самі таблиці об'єднуються операційною системою в 2-4-ярусні деревоподібну структуру, унікальну для кожного завдання. Посилання на кореневу таблицю дерева передається в ЦП при перемиканні на нове завдання, кожна з яких таким чином отримує окреме віртуальне адресне пространство.</p>
				<p><a name="PA"></a><b>PA (physical address: фізична адреса) </b> - адреса, одержувана трансляцією з <a href="#VM">віртуального</a> і необхідна для доступу в <a href="#cache">кеши</a> і пам'ять. </p>
				<p><a name="page"></a><b>page, сторінка </b> - елементарний блок пам'яті при виділенні <a href="#VM">віртуальної пам'яті</a> програмі. Молодші біти <a href="#VA">віртуального адреса</a> позначають зміщення всередині сторінки. Решта бітів задає початковий (базову) адресу, щоб транслювати. Для архітектури <a href="#x86">x86</a> найчастіше використовуються сторінки по 4 КБ, але також доступні «великі» сторінки: для 32-бітного режиму - на 4 МБ, а для 64-бітного - на 2 МБ і 1 ГБ. </p>
				<h3><a name="2"></a>Команди x86 та їх набори</h3>
				<p><a name="x86"></a><b>x86</b> - найпопулярніша <a href="#ISA">архітектура</a> для універсальних комп'ютерів. Спочатку створена як 16-бітна версія для процесорів Intel i8086 і i8088, що застосовувалися в перших IBM PC, значно оновлена і розширена до 32-бітової версії при виході ЦП i80386, далі продовжувала розширюватися за рахунок додаткових піднаборів команд. Як правило, під x86 розуміється найбільш сучасна її версія - </a href="#x86-64">x86-64</a>. З огляду на всі додатки (найчастіше, які були введені самою Intel), в x86 зараз більше 500 команд. Число регістрів в <a href="#RF">РФ</a> (включаючи <a href="#GPR">РЗП</a>) - 8 або 16. Довжина одинарного слова даних - 2 байта. </p>
				<p>Склад команди x86:</p>
				<ul class="ul"><li>один або кілька <a href="#prefix">префіксів</a>;</li><li><a href="#opcode">опкод</a>;</li><li>байт modR/M, кодує типи операндів і реєстрові операнди;</li><li>байт SIB, кодує регістри для доступу до пам'яті при складних видах адресації;</li><li>адреса або (частіше) адресний зсув (address displacement);</li><li>безпосередній операнд (imm, immediate).</li></ul>
				<p>Обов'язковий тільки опкод, але в більшості команд також є кілька префіксів і байт modR/M. Оригінальна x86 кодує операнди <a href="#destructive">руйнівним чином.</a></p>
				<p><a name="x86-64"></a><b>x86-64</b> - 64-бітна розширення архітектури x86. Основні зміни:</p>
				<ul class="ul"><li>розширена розрядність РЗП до 64 біт;</li><li>подвоєно до 16 число РЗП і регістрів <a href="#xmm">xmm</a> (але не <a href="#x87">x87</a>);</li><li>скасовані деякі старі команди і режими.</li></ul>
				<p>Якщо в 64-бітної команді використовується хоча б один регістр з доданих, їй потрібен додатковий REX-<a href="#prefix">префікс</a>, який вказує відсутні біти в кодах регістрів.</p>
				<p><a name="AMD64"></a><b>AMD64, EM64T, Intel 64</b> — комерційні назви реалізацій архітектури x86-64, використані AMD, Intel (раніше) і Intel (пізніше). Практично ідентичні.</p>
				<p><a name="prefix"></a><b>prefix, префікс</b> - частина команди, що модифікує її виконання або доповнює <a href="#opcode">опкод</a>. У x86 буває декількох видів: </p>
				<ul class="ul"><li>перемикачі таблиць опкодів або режимів декодування;</li><li>покажчики на половини необхідних команді <a href="#RF">реєстрових файлів</a> (REX-префікси для <a href="#x86-64">64-бітного режиму</a>);</li><li>покажчики на один з сегментних регістрів (застаріли);</li><li>блокувальник доступу до пам'яті (застарів);</li><li>повторювачі команди (рідко використовуються і доступні лише для деяких команд);</li><li>модифікатори розрядності операнда і адреси (застаріли).</li></ul>
				<p>Використання префіксів збільшує команду і є наслідком ранніх спроб Intel вкоротити найбільш часті команди x86, а пізніше - наслідком додавання нових команд, зберігаючи старі. Через префіксів важко визначити довжину команди, що обмежує швидкість виконання і вимагає складної логіки для </a href="#ILD">довжиноміра</a> і <a href="#ID">декодера</a>. У кожного x86-ЦП є обмеження на максимальну кількість префіксів в команді, при якому досяжна пікова швидкість виконання.</p>
				<p><a name="opcode"></a><b>opcode, опкод</b> - головна частина команди, що кодує операцію (і) і тип і розрядність операндів. У x86 кодується одним байтом, чого вистачає приблизно для 100 команд, т. к. більшість з них мають кілька варіантів типів і розрядностей операндів. Для збільшення числа команд застосовуються <a href="#prefix">префікси</a>-перемикачі таблиць опкодов. Найчастіше, в коді з <a href="#SIMD">векторної</a> обробкою команди мають по 2-3 перемикача. </p>
				<p><a name="x87"></a><b>x87</b> — доповнення до архітектури x86, що описує команди для роботи зі скалярними <a href="#float">дійсними</a> числами, виконуваними блоком <a href="#FPU">FPU</a>. Зараз набір x87 мало затребуваний через можливість зручно і швидко виконувати скалярні речові обчислення в регістрах <a href="#xmm">xmm</a>. </p>
				<p><a name="F"></a><b>F… (float: дійсний)</b> — приставка до мнемоніки команд <a href="#x87">x87</a> і до назв <a href="#float">дійсних</a> <a href="#FU">ФП</a> (включаючи <a href="#SIMD">векторні</a>).</p>
				<p><a name="HP"></a><b>HP, SP, DP, EP (half-, single, double, extended precision: половинна, одинарна, подвійна, розширена точність)</b> - формати представлення <a href="#float">дійсного</a> числа в більшості ЦП і сопроцесорів.</p>
				<table class="table-mpt">
					<tr class="purple">
						<td>Формат</td>
						<td>HP</td>
						<td>SP</td>
						<td>DP</td>
						<td>EP</td>
					</tr>
					<tr class="grey">
						<td class="purple">Розмір, байт*</td>
						<td>2</td>
						<td>4</td>
						<td>8</td> 
						<td>10</td>
					</tr>
					<tr class="lilak">
						<td class="purple" rowspan="3">Особливості</td>
						<td>В ЦП доступний лише як аргумент для <a href="#CVT16">перетворення</a> в SP і назад</td>
						<td colspan="2">В <a href="#SSE">SSE</a>-командах SP і DP скорочуються як S і D</td>
						<td>Використовується тільки в <a href="#x87">x87</a> і вважається надмірним</td> 
					</tr>
					<tr class="grey">
						<td colspan="2">Як правило, для мультимедійних обчислень потрібні HP і SP ...</td>
						<td>... а для наукових - DP</td>
						<td></td>
					</tr>
					<tr class="lilak">
						<td colspan="2">Сучасні <a href="#GPU">GPU</a> можуть використовувати 100% ресурсів для обчислень з HP і SP ...</td>
						<td>... але не з DP</td>
						<td></td>
					</tr>
				</table>
				<p>* - більший розмір дозволяє мати велику точність і діапазон ступенів.</p>
				<p><a name="CVT16"></a><b>CVT16, F16C</b> — набор з двох команд для перетворення <a href="#float">дійсних</a> чисел з <a href="#HP">HP в SP</a> і навпаки. </p>
				<p><a name="MMX"></a><b>MMX (matrix math extension: розширення [для ISA додаванням] матричної математики; або multimedia extension: мультимедійні розширення) </b> - перше застосування парадигми <a href="#SIMD">SIMD</a> в x86: набір команд для роботи з векторами довжиною 8 байт, розташованими в стеці регістрів <a href="#FPU">FPU</a> (mm-регістри) і містять 2, 4 або 8 <a href="#integer">цілих</a> елементів по 4, 2 або 1 байт, відповідно. Застарів після виходу піднабора <a href="#SSE2">SSE2</a>. </p>
				<p><a name="EMMX"></a><b>EMMX (extended MMX: розширене MMX)</b> - розширення <a href="#MMX">MMX</a> введені AMD і Cyrix. Були малопопулярні навіть під час активного використання оригінального MMX. </p>
				<p><a name="P"></a><b>P ... (packed: «упакована»)</b> - приставка до мнемоніки <a href="#SIMD">векторних</a> <a href="#integer">цілочисельних</a> команд x86 і команд <a href="#3DNow">3DNow</a>. </p>
				<p><a name="3DNow"></a><b>3DNow!</b> - перше застосування парадигми <a href="#SIMD">SIMD</a> для <a href="#float">дійсних</a> чисел в x86: набір команд для роботи з векторами довжиною 8 байт, розташованими в стеці регістрів <a href="#FPU">FPU</a> і які містять по два <a href="#SP2">SP</a>-елемента. Використовувався тільки в процесорах AMD. Застарів після виходу піднабора <a href="#SSE">SSE</a>. </p>
				<p><a name="SSE"></a><b>SSE (streaming SIMD extensions: потокові SIMD-розширення)</b> — піднабори <a href="#SIMD">SIMD</a>-команд для векторів, що зберігаються в окремому <a href="#RF">регістровому файлі</a> з 16-байтовими регістрами <a href="#xmm">xmm</a>. Оригінальний SSE працював тільки з <a href="#SP">SP</a>-елементами. Далі доповнювався кілька разів: SSE2 - робота з <a href="#integer">цілими</a> і DP-елементами; SSE3, SSSE3, SSE4.1, SSE4.2, SSE4.a - специфічні команди для конкретних видів програм (медіа-кодування, комплексні обчислення, робота з текстом і ін.). Речові SSE-операції можуть бути і скалярними, використовуючи тільки молодший елемент вектора. Мнемоніка дійсної SSE-команди складається з:</p>
				<ul class="ul"><li>короткої назви операції (часто збігається з назвою виконуючого її <a href="#FU">ФП</a>);</li><li>букви S (scalar, скалярна) або P (packed, векторна, «упакована»);</li><li>букви S (для SP) або D (для DP).</li></ul>
				<p><a name="xmm"></a><b>xmm</b> - загальна назва 16-байтового регістра для команд <a href="#SSE">SSE</a>. </p>
				<p><a name="AVX"></a><b>AVX (advanced vector extensions: просунуті векторні розширення) </b> — надбудови над звичайним способом кодування команд x86. AVX-код дозволяє: </p>
				<ul class="ul"><li>обробляти 32-байтові <a href="#SIMD">вектори</a> в регістрах <a href="#ymm">ymm</a> (цілочисельна арифметика і зрушення - починаючи з версії AVX2);</li><li>використовувати в усіх векторних командах 3-4 операнда в <a href="#non-destructive">неруйнуючої формі</a>;</li><li>заощадити на розмірі векторних команд заміною кількох старих <a href="#prefix">префіксів</a> одним обов'язковим VEX-байтом.</li></ul>
				<p>Також додані нові векторні і скалярні (в AVX2) команди. Мнемоніки команд AVX мають приставку V.</p>	
				<p><a name="ymm"></a><b>ymm</b> — загальна назва 32-байтового регістра для команд <a href="#AVX">AVX</a>. Сумісні з регістром <a href="xmm">xmm</a> з тим же номером, т. к. останній представляється молодшою половиною першого. </p>
				<p><a name="XOP"></a><b>XOP (extended operation: розширена операція)</b> - надбудова компанії AMD, яка доповнює набір <a href="#AVX">AVX</a> командами <a href="#FMA">FMA</a> і іншими векторними. Має ті ж переваги і обмеження (наприклад, в поточній версії для цілих доступна тільки 16-байтова обробка), але відрізняється кодуванням (зокрема, використовує обов'язковий XOP-байт). </p>
				<p><a name="FMA"></a><b>FMA (fused multiply-add: злите множення-складання)</b> - піднабор команд для злитих множення-додавання і множення-віднімання. Реалізується в блоці <a href="#MAD">MADD</a> двома варіантами: </p>
				<ul class="ul"><li>загальний, 4-операндний, <a href="#non-destructive">неруйнівний</a> FMA4 (D = ± A × B ± C);</li><li>приватний, 3-операндний, <a href="#destructive">руйнівний</a> FMA3 (A = ± A × B ± C або B = ± A × B ± C або C = ± A × B ± C).</li></ul>
				<p>FMA-команда відрізняється підвищеною швидкістю (злита операція швидше двох роздільних) і точністю (не відбувається проміжного округлення твори).</p>
				<p><a name="AMD-V"></a><b>AMD-V, VT (virtualization technology: технологія віртуалізації)</b> - технології апаратної підтримки віртуалізації в ЦП AMD і Intel. Практично ідентичні. Віртуалізація дозволять одночасно запускати кілька програмно ізольованих ОС, розділяючи між ними апаратні ресурси. </p>
				<p><a name="AES-NI"></a><b>AES-NI (AES new instructions: нові команди [для] AES)</b>- піднабор команд для прискорення операцій (де)шифрування за стандартом AES. Сюди ж можна віднести PCLMULQDQ - команду безпереносного множення, що прискорює алгоритми шифрування. Використовують векторні регістри <a href="#xmm">xmm</a> і <a href="#ymm">ymm</a>. </p>
				<p><a name="PadLock"></a><b>PadLock </b> - піднабір команд для прискорення операцій (де)шифрування для всіх популярних шифрів, включаючи AES. Також включає апаратний генератор випадкових чисел, застосовуваний для криптографічних програм. Застосовується в ЦП VIA. </p>
				<p><a name="CPUID"></a><b>CPUID (CPU identify: ідентифікація ЦП)</b> - команда видачі <a href="#CPUID">«паспорта процесора»</a> з перерахуванням всіх основних якісних та кількісних характеристик, включаючи підтримувані піднабори команд. </p>
				<p><a name="MSR"></a><b>MSR (model-specific register: специфічний для моделі регістр) </b> - регістр спеціального призначення для апаратного налаштування будь-якої функції або режиму ЦП. У x86-ЦП MSR-регістрів кілька сотень, причому їх кількість і використання визначаються <a href="#microarchitecture">мікроархітектурою</a> і не залежать від програмної архітектури ЦП. Для призначених для користувача програм найчастіше недоступні. </p>
				<p><a name="load-op"></a><b>load-op, load-ex (завантаження-виконання)</b>- варіант команди, що використовує дані в пам'яті як один з <a href="#operand">джерел</a>. Вимагає наявність в команді адреси операнда в пам'яті, або вказівки адресних компонент в регістрі(ах) і самій команді. В останньому випадку арифметичні операції з компонентами виконуються в <a href="#AGU">AGU</a> до завантаження операнда і виконання основної дії. </p>
				<p><a name="load-op-store"></a><b>load-op-store (завантаження-виконання-збереження)</b> - варіант команди, що використовує дані в пам'яті як <a href="#operand">модіфіканд</a>. Крім вимог до командам типу <a href="#load-op">load-op</a>, також іноді потрібен атомарний обмін з пам'яттю: якщо між читанням аргументу і записом результату одним ядром до цього ж значенням звернеться інше, то для забезпечення цілісності даних друге звернення потрібно блокувати, що в многоядерній системі досить складно. </p>
				<p><a name="mov"></a><b>mov (move: «переміщення, рух»)</b>- команда копіювання даних. </p>
				<p><a name="cmov"></a><b>cmov (conditional move: умовне переміщення)</b> - команда <a href="#conditional">умовного</a> копіювання. Використання cmov дозволяє прискорити програму за рахунок зменшення числа <a href="#mispredict">труднопередбачених</a> умовних <a href="#jmp">переходів</a>. </p>
				<p><a name="jmp"></a><b>jmp (jump: стрибок), перехід </b> - команда передачі управління, яка вказує адресу іншої команди, що виконується після переходу. Різні варіанти переходів реалізують структурні конструкції програми. Види переходів: </p>
				<ul class="ul"><li>безумовний - відбувається завжди;</li><li><a href="#conditional">умовний</a>;</li><li>циклічний - умовний перехід після модифікації лічильника циклу і перевірки умови виходу з нього; рідко застосовується;</li><li>виклик підпрограми і повернення з неї;</li><li>виклик переривання і повернення з нього.</li></ul>
				<p>Поведінка переходів <a href="#BPU">передбачається</a> заздалегідь, найчастіше вдало.</p>
				<p><a name="nop"></a><b>nop (no operation: немає операції), ноп</b> - єдина команда, що не кодує операцію. Найчастіше використовується як «затичка» для заповнення місця при налагодженні або <a href="#align">вирівнюванні</a> коду. У деяких архітектурах (включаючи x86) НОП як окремий опкод відсутня, тому замінюється комбінацією простої команди і операндів, що не змінює стан процесора (крім покажчика на виконувану команду). У x86 має довжину 1-15 байт.</p>
				<h3><a name="3"></a>Загальний пристрій конвеєра</h3>
				<p><a name="pipline"></a><b>pipeline («трубопровід»), конвеєр</b> - в загальному випадку: організація виконання операцій одночасним виконанням роботи на кількох етапах (<a href="#stage">стадіях</a>), кожен з яких виконує частину дій, для збільшення загальної продуктивності. У процесорі: основна частина <a href="#core">ядра</a>, виконуюча програму конвеєрним принципом. Конвеєр може бути простим (<a href="#way">однопутним</a>) і <a href="#superscalar">суперскалярні</a> (багатопутні). </p>
				<p><a name="stage"></a><b>stage, стадія</b> - одна з декількох частин <a href="#pipline">конвеєра</a>. Як правило, кожен такт стадії виконує одне або кілька простих дій в одному блоці, передає результат в наступну стадію і приймає результат попередньої. При неможливості виконати що-небудь з цих дій впадає в <a href="#stall">ступор</a>.  </p>
				<p><a name="stall"></a><b>stall, ступор</b> - зупинка роботи <a href="#pipline">конвеєра</a> або однієї або декількох його <a href="#stage">стадій</a> через брак будь-якого ресурсу. Ступор однієї стадії протягом одного такту називається міхур (bubble). Щоб уникнути ступору і наближення досяжної продуктивності до її теоретичного максимуму застосовуються численні методи підтримки конвеєра в максимально завантаженому стані.</p>
				<p><a name="way"></a><b>way («шлях») </b> - в <a href="#pipline">конвеєрі</a>: магістраль для проходження одного потоку <a href="#instruction">команд</a> або <a href="#mop">мопов</a>. Число шляхів застосовується до всього конвеєру і обмежує максимальну величину <a href="#superscalar">суперскалярного</a>, хоча між деякими суміжними стадіями число шляхів може бути більше. </p>
				<p><a name="superscalar"></a><b>superscalar, суперскалярний</b> - <a href="#pipline-way">многопутний</a> <a href="#pipline">конвеєр</a>, що обробляє більше <a href="#IPC">однієї команди за такт</a>, або процесор, що володіє <a href="#core">ядром(ами)</a> з таким конвеєром, або <a href="#microarchitecture">мікроархітектура</a>, яка описувала такий конвеєр. </p>
				<p><a name="front-end"></a><b>front-end («передня частина»), фронт конвеєра</b> - частина <a href="#pipline">конвеєра</a>, що читає і обробна <a href="#instruction">команди</a>, готуючи їх для виконання в <a href="#back-end">тилу</a> у вигляді <a href="#mop">мопов</a>. Включає в себе стадії від <a href="#BPU">провісника переходів</a> до <a href="#decoder">декодера</a> або розташованих після нього <a href="mop-buffer">буфера</a> і/або <a href="#mop-cache">кеша</a> мопов (в разі їх присутності). У термінах Intel буфер мопов відокремлює фронт і тил, так що запис в нього є останньою стадією фронту. </p>
				<p><a name="back-end"></a><b>back-end («задня частина»), тил конвеєра</b> - частина <a href="#pipline">конвеєра</a>, обробна дані виконанням <a href="#mop">мопов</a> від <a href="#front-end">фронту</a>. Включає в себе <a href="#stage">стадії</a> від читання з <a href="#mop-buffer">буфера мопов</a> і <a href="#allocate">розміщення</a> мопов в розділі <a href="#scheduler">планувальник(ах)</a> до їх <a href="#retire">відставки</a>. Безпосередньо обробка даних здійснюється тільки стадією виконання, проте до тилу відносять також інші частини <a href="#datapath">виконавчого тракту</a>, <a href="#dispatcher">диспетчер</a> і планувальник (і). <a href="#cache">Кеши</a>, <a href="#LSU">LSU</a> і інші блоки підсистеми пам'яті номінально не є частиною конвеєра, незважаючи на те, що при обробці доступів в пам'ять LSU повинен спрацювати до відставки зажадав доступ команди. </p>
				<p><a name="mop"></a><b>μop, mop, мікрооперація, моп </b> - </a href="#RISC">RISC</a>-подібна <a href="#instruction">команда</a> (невірно названа <a href="#operation">операцією</a>) у внутрішньому форматі ЦП, виконуюча одне або кілька елементарних дій. Команди <a href="#CISC">CISC</a>-ЦП переводяться в мопи в <a href="#ID">декодере</a>, причому кожна проста команда генерує один моп, а складна - кілька. У RISC-ЦП декодер складається лише з простих блоків, що виконують нескладну підготовку команд для виконання. Одна CISC-команда породжує в середньому більше одного мопа, а число <a href="#pipline-way">шляхів</a> конвеєра до і після декодера найчастіше однаково, що створює дисбаланс навантажень на стадії. Для його виправлення застосовуються <a href="#microfusion">мікрозлиття</a> і <a href="#macrofusion">макрозлиття</a>. </p>
				<p><a name="microfusion"></a><b>microfusion, мікрозлиття</b> - можливість одним <a href="#mop">мопом</a> закодувати дві <a href="#operation">операції</a>, щоб зменшити навантаження на <a href="#pipline">конвеєр</a> для деяких щодо складних команд. Найчастіше мікрозлитим мопом кодується одна обчислювальна операція і один пов'язаний з нею доступ в пам'ять, включаючи обчислення адреси. Злиті мопи поділяються на два окремих перед виконанням в тилу. </p>
				<p><a name="macrofusion"></a><b>macrofusion, макрозлиття</b> - надбудова над <a href="#microfusion">мікрозлиттям</a>, що дозволяє одним <a href="#mop">мопом</a> закодувати дві (рідко більше) команди, щоб збільшити значення <a href="#IPC">IPC</a> на 1 (більше одного мікрозлиття за такт <a href="microarchitecture">мікроархітектури</a> <a href="#x86">x86</a>-ЦП не допускають). Варіанти зливаємих команд: </p>
				<ul class="ul"><li>порівняння + умовний <a href="#jmp">перехід</a>;</li><li>змінююча <a href="#flags">прапори</a> арифметична або логічна команда + умовний перехід (більш загальний варіант попереднього пункту);</li><li>будь-яка команда, крім <a href="#nop">нопа</a> + ноп + (необов'язково) будь-яка команда, відповідна критеріям вище;</li><li>копіювання «регістр-1 ← регістр-2» + обчислювальна команда з регістром-1 як <a href="#operand">модіфікандом</a>.</li></ul>
				<p>Із-за фіксованого розміру <a href="mop">мопа</a> на <a href="#operand">операнди</a> пари команд накладаються обмеження: не більше одного доступу в пам'ять, не більше одного безпосереднього операнда (іноді не допускається зовсім) і т.п.</p>
				<p><a name="in-order"></a><b>in-order, по черзі</b> - про послідовну обробку або виконанні команд і мопов в зазначеному програмою порядку. <a href="#front-end">Фронт</a> конвеєра завжди обробляє команди впорядковано. <a href="#back-end">Тил</a> обробляє дані по черзі або <a href="#OoO">позачергово</a>. </p>
				<p><a name="speculative"></a><b>speculative (гіпотетичний), спекулятивний, попереджуючий</b> - наступний за принципом попередження: виконання роботи до підтвердження необхідності її результатів. У <a href="#pipline">конвеєрних</a> процесорах - завантаження і/або виконання найбільш ймовірних команд і/або даних. Попередження застосовується, щоб не <a href="#stall">зупиняти</a> частину конвеєра в очікуванні точного результату, коли дані або коди, потрібні для роботи поточної <a href="#stage">стадії</a>, будуть отримані лише через кілька тактів в одній з наступних. Перевірка вірності попередження для команд відбувається при <a href="#retire">відставці</a>, а для даних можлива і раніше. Попередження для команд застосовується при <a href="#BPU">прогнозі розгалужень</a> і <a href="#OoOE">позачергово виконанні</a>, а для даних - при предзагрузкі і позачергово доступі до пам'яті. </p>
				<p><a name="OoO"></a><b>OoO (out-of-order), позачерговість</b> - <a href="#speculative">попередження</a> для команд при обробці <a href="#mop">мопов</a>: обробка в порядку, найбільш зручному ядру в даний момент. Застосовується до тилу конвеєра: окремо до виконавчої частини (<a href="#OoOE">OoOE</a>) і доступу в пам'ять (<a href="#MD">memory disambiguation</a>). Вимагає наявності апаратної структури, що зберігає оригінальний порядок мопов (виходячи з послідовності породили їх команд) для їх <a href="#in-order">почергової</a> <a href="#retire">відставки</a>. </p>
				<p><a name="OoOE"></a><b>OoOE (out-of-order execution), позачергово виконання</b> - концепція <a href="#OoO">позачерговості</a>, застосовувана при виконанні мопов: моп запускається на виконання, коли готові всі його <a href="#operand">операнди</a> і цільове <a href="#FU">ФП</a>, навіть якщо декодувані до нього мопи ще не виконані. Є одним з видів <a href="#speculative">попередження</a> для команд. </p>
				<p><a name="SMT"></a><b>SMT (simultaneous multithreading: одночасна багатопоточність)</b> - віртуальна <a href="#SMP">багатопроцесорність</a>: одночасне виконання <a href="#pipline">конвеєром</a> одного <a href="#cote">ядра</a> декількох потоків для мінімізації <a href="#stall">ступор</a>. При цьому більшість ресурсів конвеєра використовується всіма потоками. </p>
				<p><a name="HT"></a><b>HT (Hyper-Threading), гіперпоточність</b> - «тонка» версія <a href="#SMT">SMT</a> в ЦП Intel: кожен такт кожна стадія <a href="#pipline">конвеєра</a> або їх група вибирає один з двох або обидва потоку команд або мопов, виходячи з готовності ресурсів для кожного з них. </p>
				<p><a name="MCMT"></a><b>MCMT (multicluster multithreading: многокластерна многопоточність) </b> - прискорює продуктивність рішення AMD, проміжне між <a href="#SMP">SMP</a> і <a href="#SMT">SMT</a>: виконуючий два потоку <a href="#pipline">конвеєр</a> ділиться на паралельно працюють кластери по кілька стадій кожна, причому одні кластери поділяють свої ресурси між потоками (як в SMP), а інші виділяються їм монопольно (як в SMT) . </p>
				<p><a name="IPC"></a><b>IPC (instructions per clock), команд (-а, -и) за такт </b> - міра продуктивності <a href="#pipline">конвеєра</a>, його <a href="#EX">виконавчої стадії</a> або окремого <a href="#FU">ФП</a>. Пікова величина IPC вимірюється при виконанні потоку <a href="#instruction">команд</a> або <a href="#mop">мопов</a>, незалежних один від одного за даними, що дозволяє по можливості здійснити їх одночасне виконання. </p>
				<p><a name="CPI"></a><b>CPI (clocks per instruction), такт (-а, -ов) на команду </b> - величина, зворотна <a href="#IPC">IPC</a>. Застосовується для зручності, коли IPC <1. </p>
				<p><a name="OPC"></a><b>OPC (operations per clock), операція (-ії, -й) за такт </b> - величина, аналогічна <a href="#IPC">IPC</a>, але що заміряє <a href="#operation">операції</a> виконуємих <a href="#instruction">команд</a> або <a href="#mop">мопов</a>. При обчисленні пікової величини OPC <a href="#pipline">конвеєра</a>, як правило, враховуються лише обчислювальні команди, і тільки над даними, а не адресами. </p>
				<p><a name="FLOPC"></a><b>FLOPC (float operations per clock: речові операції за такт), флоп (-а, -ів) за такт</b> - величина <a href="#OPC">OPC</a> для <a href="float">дійсних</a> обчислювальних команд. Застосовується до <a href="#core">ядра</a>, а при множенні на число ядер - до всього <a href="#CPU">процесору</a>. </p>
				<p><a name="FLOPS"></a><b>FLOPS (FLoat Operations Per Second: речові операції в секунду), флопс</b> - множення <a href="base-freq">базової частоти</a> процесора на число <a href="#FLOPC">флопов/такт</a>. Застосовується до <a href="#core">ядра</a>, а при множенні на число ядер - до всього <a href="#CPU">процесору</a>, будучи в цьому випадку однією з його головних швидкісних характеристик. </p>
				<p><a name="latency"></a><b>latency, латентність, затримка</b> - число тактів між подачею команди на виконання і його завершенням. Застосовується для опису «хронологічній довжини» <a href="#pipline">конвеєра</a> (близькою до числа стадій) і тривалості виконання команди в <a href="#FU">ФП</a> або доступу в <a href="#cache">кеш</a> або пам'ять. Більшість команд мають постійну затримку, майже не залежить від вмісту оброблюваних даних. Звернення до підсистеми кешей і, особливо, до пам'яті мають змінний характер затримки, тому для них вказуються мінімальна і середня затримки. </p>
				<p><a name="throughput"></a><b>throughput, пропуск, темп, ПС (пропускна здатність) </b> - о командах: зворотна пропускна здатність - значення <a href="#CPI">CPI</a> при виконанні мопа(ів) цієї команди для окремого <a href="#FU">ФП</a>, або всієї виконавчої <a href="#stage">стадії</a> конвеєра. ФП з пропуском в 1 CPI є повноконвейерним, тобто які приймають на виконання новий моп кожен такт, при тому, що затримка може бути більше 1 такту. ФП з пропуском 2 є напівконвеєрним, а з пропуском, (майже) рівним затримки, - неконвейерним. Дробові значення пропуску команд виходять при <a href="#superscalar">суперскалярному</a> виконанні. Наприклад, 0,5 означає наявність або двох однакових конвеєрних (для виконання даної команди) ФП, або чотирьох напівконвеєрних, а 1,5 - наявність двох однакових ФП з CPI = 3. </p>
				<p>Об інших стадіях: значення <a href="#IPC">IPC</a> для стадії. Як правило, збігається з числом шляхів конвеєра в ній.</p>
				<p>Про кеш, пам'ять і з'єднуючих їх з ядром шинах: пряма пропускна здатність в байтах/такт або байтах/секунду. Пікова ПС являється добутком розрядності шини, числа переданих кожною лінією бітів/такт і (для Б/c) частоти. Фактична ПС часто в 1,5-2 рази менше пікової. При вказівці приставок кратності (кіло, мега, гіга-, ...) маються на увазі десяткові похідні (10<sup>3</sup>, 10<sup>6</sup>, 10<sup>9</sup>, ...), а не виконавчі (2<sup>10</sup> = 1,024 · 10<sup>3</sup>, 2<sup>20</sup>≈1,049 · 10<sup>6</sup>, 2<sup>30</sup>≈1,074 · 10<sup>9</sup>, ...). ПС пам'яті скорочується як ПСП, а кеша - ПСК.</p>
				<p><a name="timing"></a><b>timing, часовий параметр, таймінг</b> - загальна назва <a href="TP">пропускання</a> і <a href="#latency">затримки</a>. Найчастіше застосовується до команд і доступу до підсистеми пам'яті. </p>
				<h3><a name="4"></a>Cтадії конвеєра</h3>
				<p><a name="BPU"></a><b>BPU (branch predictor unit: блок пророкування розгалужень), провісник переходів</b> - початкова частина конвеєра, що реалізує один з видів <a href="#speculative">попередження команд</a>. Прогнозує поведінку команд <a href="#jmp">переходу</a> (цільової адресу і припущення про виконання), використовуючи накопичену в спеціальних таблицях і регістрах статистику про дійшедших до <a href="#retire">відставки</a> переходах. Складається з 1-2 стадій, працює окремо від решти конвеєра і раз в 2-3 такта видає ймовірний адрес наступної <a href="#IChunk">порції команд</a> для виконання. Для переходів різного типу застосовує різні алгоритми. Прогнози даються на кілька переходів вперед незалежно від темпу реального виконання команд або навіть їх наявності в кеші <a href="#L1I">L1I</a>. </p>
				<p><a name="IF"></a><b>IF (instruction fetch: завантаження команд)</b> - кілька стадій (число яких збігається з <a href="#latency">затримкою</a> кеша <a href="#L1I">L1I</a>), витрачаються на завантаження <a href="#chunk">порції команд</a> з L1I в <a href="#predecoder">предекодер</a> або <a href="#ID">декодер</a> <a href="#BPU">за передбаченою</a> адресою. </p>
				<p><a name="IChunk"></a><b>IChunk (instruction сhunk: «шматок команд»), порція команд </b> - блок команд, що завантажується з <a href="#L1I">L1I</a> в <a href="#predecoder">предекодер</a> або <a href="#ID">декодер</a>. У <a href="#x86">x86</a> ЦП - 16 або 32 байта. </p>
				<p><a name="predecoder"></a><b>predecoder, предекодер</b> - попередній <a href="#decoder">декодер</a>, що розділяє декілька <a href="#CISC">CISC</a>-команд з <a href="#chunk">порції</a> на окремі елементи (див. <a href="#x86">x86</a>), використовуючи інформацію від <a href="#ILD">довжиноміра</a>. Підготовка команд може відбуватися наперед їх подальшої обробки декодером, якщо до нього є <a href="#buffer">буфер</a>. </p>
				<p><a name="ILD"></a><b>ILD (instruction length decoder: декодер для команд), довжиномір</b> - визначник довжин <a href="#CISC">CISC</a>-команд. У <a href="#x86">x86</a>-ЦП аналізує їх <a href="#prefix">префікси</a>, <a href="#opcode">опкоди</a> і байти modR/M. В ЦП Intel довжиномір є частиною <a href="#predecoder">предекодера</a>, вимірюючи довжини «на льоту». У більшості ЦП AMD він працює з командами при їх завантаженні з <a href="#L2">L2</a> в <a href="#L1I">L1I</a>, зберігаючи розмітку байтів команд в додаткових бітах в L1I, зчитувальних предекодером при завантаженні <a href="#chunk">порції</a>.</p>
				<p><a name="ID"></a><b>ID (instruction decoder: декодер команд), decoder (декодер)</b> - набір блоків, що перетворюють команди в <a href="#mop">мопи</a>. У <a href="#x86">x86</a>-ЦП складається з декількох <a href="#translator">трансляторів</a> і одного <a href="#microsequencer">мікросеквенсера</a> (генератора послідовності мопов) з ПЗУ для <a href="#microcode">микрокода</a>. Здійснює <a href="#microfusion">мікрозлиття</a> і <a href="#macrofusion">макрозлиття</a>. </p>
				<p><a name="translator"></a><b>translator («перекладач»), транслятор </b> - частина <a href="#ID">декодера</a>, оброблююча прості і часті команди без використання <a href="#microcode">микрокода</a>. У <a href="#x86">x86</a>-ЦП Intel є 1-3 простих транслятора (на 1 менше числа <a href="#pipline-way">шляхів</a> конвеєра), кожен з яких переводить команду в 1 моп за такт, і 1 складний транслятор, що переводить команду в 1-4 мопа/такт. Як правило, число генеруємих трансляторами мопів не більше числа шляхів. Більшість ЦП AMD мають 3-4 транслятора, кожен з яких переводить команду в 1-2 мопа/такт. <a href="#macrofusion">Макрозлиття</a> команди обробляються парами будь-яким транслятором, але не більше однієї пари за такт. </p>
				<p><a name="microcode"></a><b>μcode, microcode, мікрокод</b> - сукупність мікропрограм - послідовностей <a href="#mop">мопов</a> (до кількох сотень довжиною), які задають виконання найбільш складних команд, які не можуть бути оброблені <a href="#translator">трансляторами</a>. Зберігається в <a href="#mROM">ПЗУ мікропрограм</a>. </p>
				<p><a name="microsequencer"></a><b>microsequencer, мікросеквенсер</b> - частина <a href="#ID">декодера</a>, що читає прошивки з <a href="#mROM">ПЗУ з ними</a>. </p>
				<p><a name="mROM"></a><b>mROM, μROM («мікроПЗУ»)</b> - енергонезалежне сховище для <a href="#microcode">мікрокода</a> розміром в кілька сотень кілобіт. <a href="#microsequencer">Мікросеквенсер</a> <a href="#ID">декодера</a> читає прошивки з мікроПЗУ по кілька мопов за такт (згідно з кількістю <a href="#pipline-way">шляхів</a> конвеєра). Для виправлення помилок вміст може коригуватися прямим програмуванням або <a href="#fuse">перемичками</a>. </p>
				<p><a name="mop-buffer"></a><b>mop buffer, буфер мопів</b> - остання стадія <a href="#front-end">фронту</a> конвеєра, що приймає <a href="#mop">мопи</a> від декодера і/або <a href="#mop-cache">кеша мопів</a> і відправляє їх в <a href="#dispatcher">диспетчер</a>. За термінологією Intel називається IDQ (instruction decode queue: черга декодування команд). В ЦП Intel буфер мопов (як і кеш) може працювати в режимі блокування циклу, звільняючи на час його виконання інші стадії фронту для простою, накопичення мопів команд після циклу або роботи над іншим потоком (в процесорах з <a href="#SMT">SMT</a>). Виявлення та блокування циклу в IDQ здійснюється блоком LSD (loop stream detector: детектор циклічного потоку). </p>
				<p><a name="dispatcher"></a><b>dispatcher, диспетчер </b> - блок конвеєра, архітектурно займає більшу частину <a href="#back-end">тилу</a>, включаючи його першу і останню стадії. Беручи <a href="#mop">мопи</a> від <a href="#decoder">декодера</a> або <a href="#mop-buffer">буфера мопов</a>, <a href="#OoO">позачерговий</a> диспетчер здійснює <a href="#rename">перейменування регістрів</a>, <a href="#allocate">розміщення</a> мопів, прийом сигналів про завершення <a href="#EX">виконання</a> мопов і <a href="#retire">відставку</a> породивших їх команд. <a href="#in-order">Почерговий</a> диспетчер простіше: він не робить перейменування та розміщення і замінює собою <a href="#scheduler">планувальник</a>. </p>
				<p><a name="register-rename"></a><b>register rename, перейменування регістрів</b> - <a href="#in-order">почергова</a> прив'язка номера архітектурного регістра-приймача, описуваного в <a href="#ISA">ISA</a> і зазначеного в <a href="#mop">мопі</a>, до апаратного регістру (повинна точніше називатися перенумерацією). Є першою стадією <a href="#back-end">тилу конвеєра</a> і виконується <a href="#dispatcher">диспетчером</a> <a href="#allocator">перед розміщенням</a> мопа. Апаратних регістрів в 4-10 разів більше, ніж архітектурних того ж типу, що дозволяє реалізувати одночасне виконання мопов, до перейменування посилавшихся на один регістр, за рахунок видалення помилкових залежностей по операндам. Не дивлячись на почерговому операції, <a href="#superscalar">суперскалярний</a> диспетчер може не тільки перейменувати кілька регістрів за такт (враховуючи, що в мопі приймач максимум один, не рахуючи регістра <a href="#flag">прапорів</a>), але і кілька разів за такт перейменувати один і той же архітектурний регістр. Часто також перейменовуються 4-6 найважливіших прапорів і регістр управління речовими обчисленнями. Апаратні <a href="#SIMD">векторні</a> регістри іноді бувають вдвічі менше архітектурних - в цьому випадку перейменування робиться для старшої і молодшої половин архітектурного. У просунутих <a href="microarchitecture">мікроархітектури</a> мопи деяких команд (обмін, копіювання і обнулення) при роботі тільки з регістрами <a href="#EX">виконуються</a> вже на цій стадії і до розміщення не доходять. </p>
				<p><a name="allocator"></a><b>allocator, розміщувач</b> - стадія <a href="#OoO">позачергово</a> <a href="#dispatcher">диспетчера</a>, що виконує розміщення <a href="#rename">перейменованих</a> мопов в <a href="#ROB">ROB</a> і <a href="#scheduler">планувальник(ах)</a>. У деяких <a href="#microarchitecture">мікроархітектурах</a> перед попаданням в планувальник(и) <a href="#macrofusion">макро-</a> і <a href="microfusion">мікрозлиття</a> мопи поділяються. </p>
				<p><a name="ROB"></a><b>ROB (reorder buffer: «буфер зміни порядку)</b> - всупереч назві (термін Intel), зберігає оригінальний (програмний) порядок мопів, тому правильніше називається RQ (retire(ment) queue: <a href="#queue">черга</a> <a href="#retire">відставки</a>; термін AMD). Число мопов в ROB визначає так зване OoO-вікно - діапазон, всередині якого мопи можуть <a href="#OoOE">виконуватися поза програмного порядку</a>. Осередок в ROB зберігає урізану версію мопа, в якій залишені лише необхідні планувальником поля. Зокрема, якщо <a href="#dispatcher">диспетчер</a> підключений до збереженого <a href="#scheduler">планувальника</a>, то ROB після виконання мопов зберігає копії їх результатів; якщо до посилального - то він зберігає посилання на результати в <a href="#PRF">фізичному РФ</a>; жодна з версій не зберігає <a href="#opcode">опкод</a> і іншу інформацію, потрібну для <a href="EX">виконання</a> мопа. </p>
				<p><a name="SC"></a><b>SC, scheduler, планувальник</b> - логічний аналізатор, який приймає мопи від <a href="#dispatcher">диспетчера</a>, який планує і утворює їх <a href="#OoO">позачерговий</a> <a href="#issue">запуск на виконання</a> і фіксує їх завершення (вказуючи про це диспетчеру для <a href="#retire">відставки</a> породили їх команд). Планування засноване на визначенні залежності мопів по операндам і відстеження зайнятості ресурсів <a href="#EX">виконавчої стадії</a>. Види і властивості: </p>
				<table class="table-mpt">
					<tr class="purple">
						<td>Посилковий планувальник</td>
						<td>Зберігаючий планувальник</td>
					</tr>
					<tr class="grey">
						<td>Не зберігає і не переміщує мопи і дані в резервації.</td>
						<td>Зберігає в резервації мопи і дані, зрушуючи їх при кожному запуску.</td>
					</tr>
					<tr class="lilak">
						<td>Маніпулює тільки мопами і номерами перейменованих регістрів, відстежуючи архітектурні та попереджувальні записи в таблиці прив'язки.</td>
						<td>Маніпулює мопами и вже відомим (у т. ч випереджувальним) вмістом регістрів, перехоплюючі результати, які повертаються виконаними мопами.</td>
					</tr>
					<tr class="grey">
						<td>Має багатопортову резервацію, розраховану на всі ФУ.</td>
						<td>Має або одну багатопортовий резервацію, або кілька однопортових (з розподілом ФУ між ними).</td>
					</tr>
					<tr class="lilak">
						<td>Розміщуються мопи прив'язані номерами регістрів до фізичного РФ.</td>
						<td>Розміщуються мопи прив'язані номерами регістрів до випереджувальним РФ; разместітель записує в резервацію вже відомі значення їх операндів з архітектурного РФ.</td>
					</tr>
					<tr class="grey">
						<td>Після виконання мопа повертає його диспетчеру з посиланням на результат.</td>
						<td>Після виконання мопа копіює в резервацію записаний ним в попереджуючий РФ результат і повертає моп з результатом диспетчеру.</td>
					</tr>
				</table>
				<p><a name="RS"></a><b>RS (reservation station: резервації станція), резервація</b> - в посилальному розділі <a href="#scheduler">планувальник</a>: <a href="#buffer">буфер</a> готуються до виконання мопів і посилань на їх операнди в <a href="#PRF">фізичному РФ</a>. В зберігаючому планувальнику: буфер готуються до виконання мопів, що накопичує копії значень їх операндів. </p>
				<p><a name="issue"></a><b>issue («випуск»), запуск</b> - передача <a href="#mop">мопа</a> з <a href="#scheduler">планувальника</a> в <a href="#datapath">виконавчий тракт</a> для виконання. Якщо планувальник допускає зберігання в своїй <a href="#RS">резервації</a> <a href="microfusion">мікро-</a> і <a href="#macrofusion">макрозлитих</a> мопів (не вимагаючи їх поділу при розміщенні), то такі мопи запускаються по кілька разів. Обчислювальні мопи, читають аргумент з пам'яті, спочатку потрапляють в <a href="#AGU">AGU</a>, потім в <a href="#LSU">LSU</a> і, нарешті, в потрібне <a href="#FU">ФП</a> для обробки. Мопи, що зберігають аргумент в пам'яті (і які в <a href="#x86">х86</a> не бувають обчислювальними), повинні в будь-якому порядку запуститися в AGU і LSU. Кожен одержувач злитого мопа інтерпретує його по-своєму, виконуючи одну операцію. Після виконання останньої з них моп видаляється з резервації, а планувальник повідомляє <a href="#dispatcher">диспетчеру</a> про можливість <a href="#retire">відставки</a> віддаленого мопа. </p>
				<p><a name="port"></a><b>port, порт</b> - для <a href="#RF">РФ</a>: інтерфейс для однієї з шин <a href="#datapath">виконавчого тракту</a>, допускає або читання, або запису. Для <a href="#FU">ФП</a>: інтерфейс для прийому мопів або аргументів або відправки результатів. Для <a href="#RS">резервації</a>: інтерфейс для одного або декількох <a href="#FU">ФП</a>, через який йому (їм) передаються мопи або приймаються стоп-сигнали про завершення їх виконання.</p>
				<p><a name="RF"></a><b>RF (register file), РФ (реєстровий файл)</b> - набір однакових <a href="#register">регістрів</a>, що відрізняються лише номером. З точки зору <a href="#architecture">архітектури</a> в <a href="#core">ядрі</a> сучасного ЦП є як мінімум цілочисельний РФ (набір <a href="#GPR">РОПів</a> для скалярних <a href="integer">цілих</a> даних і адрес) і <a href="#SIMD">векторно</a>-<a href="#float">дійсний</a> РФ (для інших видів даних). Апаратних РФ може бути більше, причому розрядність якого-небудь з них не обов'язково збігається з розрядністю архітектурних регістрів, що зберігають в даному РФ свої значення. Має по кілька <a href="#pipline-port">портів</a> читання і запису, реалізуючи одночасний доступ, якщо немає конфліктів. </p>
				<p><a name="ARF"></a><b>ARF (architectural RF), архітектурний РФ</b> - в <a href="#in-order">почергових</a> конвеєрах: єдиний вид <a href="#RF">РФ</a>; зберігаючий поточний стан описуваних <a href="#architecture">архітектурою</a> <a href="#register">регістрів</a> і знаходиться на <a href="#datapath">виконавчому тракті</a>. У <a href="#OOO">позачергових</a> конвеєрах: РФ, який зберігає останнім достовірно відомий стан архітектурних регістрів, оновлюється при <a href="#retire">відставці</a> <a href="#mop">мопів</a>. Використовується зберігають <a href="#scheduler">планувальником</a>. В ЦП з <a href="#SMT">SMT</a> на кожен потік є або по одному ARF, або по одній таблиці прив'язки регістрів з <a href="#PRF">фізичного РФ</a> (в залежності від виду планувальника). Іноді називається RRF (retired RF, «відставлений РФ»; не плутати з renamed RF). </p>
				<p><a name="FF"></a><b>FF (future file: «файл майбутнього»), RRF (renamed RF: перейменований РФ; не плутати з <a href="#ARF">retired RF</a>), SRF (speculative RF: попереджуючий РФ)</b> - <a href="#RF">РФ</a>, який зберігає регістри з <a href="#speculative">попередженими</a> операндами і знаходиться на <a href="#datapath">виконавчому тракті</a>. Використовується зберігаючим <a href="#scheduler">планувальником</a>. </p>
				<p><a name="PRF"></a><b>PRF (physical RF), фізичний РФ (ФРФ)</b> - <a href="#RF">РФ</a>, монопольно зберігає реєстрові операнди мопів, заміщаючи <a href="#architecture">архітектурний</a> і <a href="#FF">попереджуючий</a> РФ. Використовується посилальним <a href="#scheduler">планувальником</a>. </p>
				<p><a name="RR"></a><b>RR (register read), читання регістрів</b> - стадія читання регістрів з <a href="#RF">РФ</a> і налаштування <a href="#bypass">шлюзів</a>. </p>
				<p><a name="EX"></a><b>EX (execution), виконання</b> - одна або кілька стадій виконання мопів, що містить всі <a href="#FU">ФП</a> (при <a href="#in-order">почерговому виконанні</a> сюди не включені <a href="#AGU">AGU</a>). Фактична довжина цієї стадії визначається для кожного мопа числом стадій обробного його ФП. </p>
				<p><a name="FU"></a><b>EU (execution unit: виконавчий блок), FU (functional unit: функціональний блок), ФП, функціональний пристрій</b> - блок <a href="#back-end">тилу</a>, виконуючий <a href="#mop">мопи</a> і обробляє дані і адреси. Має <a href="#pipline-port">порт</a> управління для прийому мопів з <a href="#RS">резервації</a>, 2-3 портів прийому аргументів і порт видачі результату. Найчастіше іменується за назвою виконуваної в ньому команди або групи схожих команд. Фізично знаходиться у <a href="#datapath">виконавчому тракті</a>. Для найбільш частих команд <a href="#EX">виконавча стадія</a> може містити більше одного ФП потрібного типу. Продуктивність ФП визначається <a href="#timing">таймінгами</a> виконуваних команд. </p>
				<p><a name="datapath"></a><b>datapath («шлях даних»), виконавчий тракт</b> — фізична структура <a href="#CPU">процесора</a>, реалізує обробку даних певного типу. Включає один або кілька <a href="#RF">РФ</a>, кілька <a href="#FU">ФП</a> і <a href="#bypass">шлюзів</a>. Майже всі ці блоки розташовані в ряд і пов'язані декількома шинами, по максимальному числу <a href="#pipline-port">портів</a> в підключених РФ. Шини читання передають аргументи з РФ в ФП і шлюзи, а шини запису повертають результати в шлюзи і РФ. Таким чином тракт реалізує три стадії конвеєра (а також всі проміжні між ними): <a href="#RR">читання РФ</a>, <a href="EX">виконання</a> мопов і <a href="#pipline-WB">запис в РФ</a>.  </p>
				<p><a name="bypass"></a><b>bypass («обхід»), шунт, шлюз</b> - комутатори та пов'язані з ними шини передачі даних всередині <a href="#datapath">виконавчого тракту</a> (шунт) або між ним і іншими блоками (шлюз). Кожен шунт пов'язує одну з шин записи з усіма шинами читання, дозволяючи використовувати в наступному такті результат тільки що виконаного мопа - в обхід записи в і читання з <a href="#RF">РФ</a>. Шлюзи на шинах запису ведуть в інші тракти і <a href="#LSU">LSU</a>, а на шинах читання - від них і від <a href="#scheduler">планувальника</a> (для подачі констант, включаючи адреси та адресні зміщення). </p>
				<p><a name="AG"></a><b>AG (address generation: генерація адреси)</b> - стадія арифметичних дій з вмістом регістрів і адресних зсувів, необхідна для отримання адреси аргументу в пам'яті. Виконується в <a href="#AGU">AGU</a>. При <a href="#OoOE">позачергово виконанні</a> є частиною <a href="#EX">стадії виконання</a>. </p>
				<p><a name="DCA"></a><b>DCA (data cache access: доступ до кешу даних)</b> - одна або кілька стадій читання аргументу з кешу або записи в кеш по <a href="#AG">обчисленому адресою</a> під керуванням <a href="#LSU">LSU</a>. </p>
				<p><a name="WB"></a><b>WB (write-back: зворотна запис)</b> - стадія записи результатів з <a href="#FU">ФП</a> і/або читань з пам'яті - в <a href="#RF">РФ</a> і/або в ФП (через <a href="#bypass">шлюзи</a>). Не плутати з <a href="#WB">однойменною</a> політикою роботи кеша. </p>
				<p><a name="retire"></a><b>retire, відставка, commit («вчинення»)</b> - остання стадія конвеєра і <a href="#dispatcher">диспетчера</a>, «легалізує» <a href="#in-order">в програмному порядку</a> результати команд, мопи яких знаходяться в <a href="#ROB">ROB</a>. Для цього диспетчер (в залежності від типу <a href="#scheduler">планувальника</a>) або переносить результат мопа з ROB в <a href="#ARF">архітектурний РФ</a>, або коригує використовувану для <a href="#rename">перейменування регістрів</a> таблицю посилань на <a href="#PRF">фізичний РФ</a>, щоб записаний мопом архітектурний регістр вказував на вірний фізичний. Так як у <a href="#OoO">позачерговий</a> диспетчер мопи повертаються з планувальника не обов'язково в програмному порядку, у відставку заздалегідь завершився моп може піти, тільки якщо всі попередні внесені в ROB мопи вже відставлені або йдуть в даному такті. Многомопові команди можуть відставитися тільки після відставки всіх своїх мопов. Відмова у відставці можлива в разі виявлення: </p>
				<ul class="ul"><li><a href="#exception">виключення</a> при виконанні мопа;</li><li>для <a href="#jmp">умовних переходів</a> - <a href="#mispredict">невірного</a> <a href="#BPU">передбачення переходу</a> (поведінки або адреси);</li><li>для мопов, які виконали попереджувальні читання з пам'яті - невірного <a href="#MD">передбачення адреси</a>.</li></ul>
				<p>В останніх двох випадках диспетчер повертає конвеєр в попереднє точно відомий стан («скидання конвеєра»), втрачаючи всі <a href="#speculative">попереджувальні</a> результати; успішна відставка оновлює цей стан. Відставка переходу незалежно від успішності передбачення поповнює статистику провісника.</p>
				<p><a name="exception"></a><b>exception, виняток, виняткова ситуація</b> - подія при обробці <a href="#mop">мопа</a>, що вимагає аварійної реакції: </p>
				<ul class="ul"><li>пастка - оцінний останов, системний виклик, перемикання контексту програми та ін. заздалегідь заплановані і/або очікувані випадки;</li><li>помилка виконання - відсутність <a href="#page">сторінки</a> в пам'яті, неприпустима команда, вихід за допустимий діапазон аргументу або результату і ін .;</li><li>зовнішнє переривання процесора - апаратний збій, пропажа живлення та ін.</li></ul>
				<p>При виявленні виключення <a href="#pipline">конвеєр</a> припиняє приймати нові команди і намагається довести до <a href="#retire">відставки</a> всі попередні (<a href="#in-order">в програмному порядку</a>) мопи. Якщо при цьому в них не виявлено <a href="#mispredict">фальш-пророкування</a> <a href="#jmp">переходу</a>, або інший виняток, то далі ядро запускає обробку даного.</p>
				<h3><a name="5"></a>Блоки процессора</h3>
				<p><a name="taken"></a><b>taken («узятий»), not taken («не взятий», пропущений)</b> - cпрацьовування і неспрацювання команди переходу при виконанні, а також відповідне <a href="#BPU">передбачення</a>. </p>
				<p><a name="mispredict"></a><b>mispredict («фальш-передбачення»)</b> - помилка <a href="#BPU">передбачення</a> поведінки переходу. Виявляється при <a href="#retire">відставці</a> переходу і викликає скидання конвеєра. </p>
				<p><a name="BTB"></a><b>BTB (branch target buffer: буфер цілей розгалужень)</b> - таблиця адрес, на які націлені часто зустрічаємі <a href="#imp">команди переходів</a>. Дозволяє зробити <a href="#BPU">передбачення</a>, не читаючи самі команди. Поповнюється (з витісненням старих адрес) при виконанні нового або «забутого» переходу. (Однак у деяких ЦП цільові адреси умовних переходів потрапляють в BTB, тільки якщо перехід <a href="#">«взято»</a>.) </p>
				<p><a name="GBHR"></a><b>GBHR (global branch history register: регістр глобальної історії розгалужень)</b> - регістр зсуву, який зберігає поведінку декількох останніх виконаних умовних переходів. При виконанні переходу GBHR зміщується, витісняючи самий «старий» біт і додаючи новий залежно від поведінки переходу: 1 - <a href="#taken">«взято»</a>, 0 - «пропущений». Використовується для індексації <a href="#BHT">BHT</a>. </p>
				<p><a name="BHT"></a><b>BHT (branch history table: таблиця історії розгалужень)</b> - таблиця 2-бітових лічильників, котрі пророкують поведінку переходів за 4-позиційною шкалою (від «напевно буде пропущений» до «напевно буде взятий»). Індексується кодуємою хеш-функцією, що використовує біти <a href="#GBHR">GBHR</a> і адреси переходу. </p>
				<p><a name="RSB"></a><b>RSB (return stack buffer: буфер стека повернення)</b> - частина BPU, буферизуюча адреси повернень з підпрограм, викликаних останніми. (Окремого стека для адрес повернення в x86 немає - вони знаходяться в загальному стеку серед аргументів і результатів підпрограм.) Для x86-ЦП має розмір 12-24 адреси. </p>
				<p><a name="flag"></a><b>flag, прапор</b> - 1-бітний індикатор стану. У процесорі: частина регістру прапорів, оновлюваного при виконанні деяких <a href="#instruction">команд</a> (найчастіше скалярних <a href="#integer">цілочисельних</a>). 4 найбільш важливих прапора використовуються в командах <a href="#conditional">умовного</a> виконання (в т. ч. умовних <a href="#jmp">переходах</a>). </p>
				<p><a name="domain"></a><b>domain, домен</b> - сукупність <a href="#FU">ФП</a> будь-якого <a href="#EX">виконавчого тракту</a>, використовуваних для виконання <a href="#instruction">команд</a> над <a href="#operand">операндами</a> одного типу. Тракт може мати один або декілька доменів. Якщо їх кілька, то передача даних між ними викликає затримку для спрацьовування міждоменних <a href="#bypass">шлюзів</a>. </p>
				<p><a name="ALU"></a><b>ALU (arithmetic-logic unit), АЛУ, арифметико-логічний пристрій</b> - тісно пов'язаний набір <a href="#FU">ФП</a>, виконуючий за 1 такт прості арифметичні, логічні і деякі необчислювальні команди над <a href="#integer">цілочисельними</a> операндами, будучи, таким чином, найбільш універсальним і часто використовуваним виконавчим блоком. види: </p>
				<ul class="ul"><li>ALU (без уточнень): для скалярних даних;</li><li><a href="#SIMD">SIMD</a> ALU, <a href="#SSE">SSE</a> ALU, <a href="#MMX">MMX</a> ALU: для векторних даних.</li></ul>
				<p><a name="shifter"></a><b>shifter («зсувник»)</b> - ФП або блок для бітового зсуву <a href="#integer">цілих</a> або логічних операндів. </p>
				<p><a name="AGU"></a><b>AGU (address generation unit: блок генерації адреси)</b> - арифметичне ФП для адресних компонент з команди і регістрів, фактично - <a href="#integer">цілочисельний</a> <a href="#ADD">суматор</a> з простим <a href="#shifter">зсувником</a>. </p>
				<p><a name="FPU"></a><b>FPU (floating point unit: «пристрій плаваючою точки»)</b> - блок дійсних операцій, що складається з декількох ФП. Види: </p>
				<ul class="ul"><li><a href="x87">x87</a> FPU: для скалярних даних і команд x87;</li><li><a href="#SIMD">SIMD</a> FPU, <a href="#SSE">SSE</a> FPU: для векторних даних.</li></ul>
				<p>Іноді під FPU розуміється весь векторно-речовинний <a href="#domain">домен</a>.</p>
				<p><a name="ADD"></a><b>ADD (adder: суматор)</b> - відносно елементарний ФП, який виконує додавання, віднімання, порівняння та інші прості арифметичні операції. Для <a href="#float">дійсних</a> є самостійним (FADD). Для цілих - входить до складу <a href="#ALU">ALU</a>. </p>
				<p><a name="MUL"></a><b>MUL (multiplier: множник)</b> - ФП, який виконує множення. Є найскладнішим і великим видом ФП, тому іноді для економії місця (на шкоду швидкості) робиться половинної розрядності (щодо найбільших операндів). </p>
				<p><a name="MAD"></a><b>MAD, MADD (multiplier-adder: помножувач-суматор)</b> - тісно спарені <a href="#MUL">помножувач</a> і <a href="#ADD">суматор</a>, що виконують злите множення-додавання і множення-віднімання швидше і точніше пари окремих ФП. Виконує команди <a href="#FMA">FMA</a>, окреме множення і (іноді) окремі додавання і віднімання. </p>
				<p><a name="MAC"></a><b>MAC (multiplier-accumulator: помножувач-накопичувач)</b> - невірна назва <a href="#MADD">MADD</a>. Абревіатура «MAC» входить в мнемоніку команд множення-накопичення, які є підвидом <a href="#FMA">множення-складання</a>. </p>
				<p><a name="DIV"></a><b>DIV (divider: дільник)</b> - складне неконвєрне ФП для виконання ділення (а для дійсних чисел - і добування квадратного кореня). Часто тісно пов'язаний з <a href="#MUL">помножувачем</a>. Іноді для економії замість двох спеціалізованих подільників є один універсальний - для цілих і дійсних чисел. </p>
				<p><a name="pack"></a><b>pack (упакувати), unpack (розпакувати), shuffle (тасувати, переставити)</b> - <a href="#SIMD">векторні</a> команди, виконувані в <a href="#shuffler">тасовщику</a> і змінюючі розташування елементів вектора. </p>
				<p><a name="shuffler"></a><b>shuffler (тасовщик, перестановщик)</b> - <a href="#SIMD">векторний</a> ФП, який виконує команди <a href="#shuffle">перестановки елементів</a> вектора. </p>
				<p><a name="PLL"></a><b>PLL (phase-locked loop: фазова синхронізація), помножувач частоти</b> - аналого-цифровий блок процесора, що генерує такти внутрішньої синхронізації для всієї <a href="#chip">мікросхеми</a> або її частини (ядра, загального <a href="#cache">кеша</a>, <a href="#IMC">ІКП</a> тощо) множенням зовнішньої частоти на задаваємий множник. При зміні множника добутку потрібно відносно багато часу для стабілізації на новій частоті, під час чого тактовані схеми простоюють. </p>
				<p><a name="fuses"></a><b>fuses, перемички</b> - матриця плавких перемичок для одноразового програмування або корекції роботи деяких блоків процесора (зокрема, <a href="#microcode">мікрокода</a> в <a href="#ID">декодері</a>). </p>
				<p><a name="driver"></a><b>driver, драйвер</b> - в мікроелектроніці: кінцевий пристрій зовнішньої шини (до пам'яті, периферії або процесорів), що виконує прийом і передачу сигналів і фізичний захист від перенапруги. Набори драйверів розташовані по краю <a href="#die">кристала</a>. </p>
				<h3><a name="6"></a>Підсистема пам'яті</h3>
				<p><a name="cache"></a><b>cache, «$», кеш</b> — програмно недоступна буферна пам'ять, яка використовується процесором для прискорення обміну з оперативною пам'яттю (поліпшенням <a href="#timing">таймінгов</a>) заміною звернень до ОЗУ зверненнями до самого кешу в разі кеш-<a href="#hit">попадання</a>. В ЦП має 2-4-рівневу ієрархію, причому оперативна пам'ять може вважатися додатковим (останнім) рівнем. Як правило, кожен наступний рівень кеша щодо поточного (найчастіше починаючи з L1) має ...</p>
				<table class="table-mpt">
					<tr class="purple">
						<td>... великі:</td>
						<td>... рівні або менші:</td>
					</tr>
					<tr class="grey">
						<td>інформаційний обсяг</td>
						<td>вплив на загальну продуктивність</td>
					</tr>
					<tr class="lilak">
						<td>займану площу</td>
						<td>питоме споживання енергії (вати на байт)</td>
					</tr>
					<tr class="grey">
						<td>інформаційну щільність (байти на мм²)</td>
						<td>технологічну щільність (транзистори на біт)</td>
					</tr>
					<tr class="lilak">
						<td><a href="#associativity">асоціативність</a></td>
						<td>складність реалізації</td>
					</tr>
					<tr class="grey">
						<td><a href="#latence">затримку</a></td>
						<td><a href="#TP">пропуск</a></td>
					</tr>
					<tr class="lilak">
						<td>частоту попадань</td>
						<td>частоту роботи</td>
					</tr>
				</table>
				<p>У сучасних ЦП кеші (в сумі) часто займають до половини місця на <a href="#die">кристалі</a> і більшу частину його транзисторів, але споживають енергії значно менше інших структур. В ЦП <a href="#x86">x86</a> всі кеші мають <a href="#PA">фізичну адресацію</a>, тому при зверненні до <a href="#L1">L1</a> необхідно перевести <a href="#VA">віртуальні адреси</a> в <a href="#TLB">TLB</a>.</p>
				<p><a name="mop-cache"></a><b>mop cache (кеш мопов)</b> - частина <a href="#front-end">фронту</a> конвеєра, що знаходиться перед стадією <a href="#dispatch">відправки</a>. Кеширує <a href="#ID">декодувані</a> з команд <a href="#mop">мопи</a>, тому також називається кешем 0-го рівня для мопів (L0m). У термінології Intel називається DIC (decoded instruction cache: кеш декодованих команд) або DSB (decode stream buffer: буфер потоку декодера).</p>
				<p><a name="L1"></a><b>L1 (level 1: 1-й рівень)</b> - загальна назва для першого рівня багаторівневої структури: кешей (<a href="#L1I">L1I</a> і <a href="#L1D">L1D</a> - без уточнення розуміються саме вони), <a href="#TLB">TLB</a> і (іноді) <a href="#BTB">BTB</a>.</p>
				<p><a name="L1I"></a><b>L1I (level 1 for instructions: 1-й рівень для команд)</b> - кеш для команд, підключений до <a href="front-end">фронту</a> конвеєра. Записується тільки з боку <a href="#L2">L2</a>, з боку конвеєра тільки читається. У більшості випадків 1-портовий, розрядність <a href="#cache-port">порту</a> збігається з розміром <a href="#chunk">порції команд</a>. Іноді звільняється від <a href="#ECC">ECC</a> на користь <a href="#parity">парності</a>.</p>
				<p><a name="L1D"></a><b>L1D (level 1 for data: 1-й рівень для даних)</b> - кеш для даних, підключений до <a href="#back-end">тилу</a> конвеєра. Найчастіше 2-3-портовий. Розрядність <a href="#cache-port">порту</a> або дорівнює, або вдвічі менше найбільшого операнда команд. В ЦП з <a href="#MCMT">MCMT</a> є кілька L1D на модуль.</p>
				<p><a name="L2"></a><b>L2 (level 2: 2-й рівень)</b> - загальна назва для другого рівня багаторівневої структури (кеша - по-замовчуванню, <a href="#TLB">TLB</a> або <a href="#BTB">BTB</a> - при явній вказівці), використовуваного при <a href="#miss">промаху</a> в першому рівні (<a href="L1">L1</a>). Кеш L2 майже завжди є загальним для даних і команд. У 2-рівневої схемою він також є загальним для <a href="#core">ядер</a>, в 3-рівневої - окремим, в ЦП з <a href="#MCMT">MCMT</a> - окремим для кожного модуля і загальним для його кластеров-«ядер». В ЦП <a href="#x86">x86</a> - <a href="#cache-port">1-портовий</a>.</p>
				<p><a name="L3"></a><b>L3 (level 3: 3-й рівень)</b> - кеш для даних і команд, який використовується при <a href="#miss">промаху</a> в <a href="#L2">L2</a> (інших структур з трьома і більше рівнями ієрархії в процесорах немає). Іноді називається LLC (last level cache: кеш останнього рівня), маючи на увазі, що після промаху в ньому йде звернення в пам'ять. Є загальним для <a href="#core">ядер</a> (в ЦП з <a href="#MCMT">MCMT</a> - модулів). Іноді працює на частоті, меншій, ніж у ядер. В ЦП <a href="#x86">x86</a> має по одному <a href="#cache-port">порту</a> на <a href="#bank">банк</a>, починаючи від простого 1-банкового пристрою.</p>
				<p><a name="hit"></a><b>hit, попадання</b> - ситуація знаходження потрібної інформації при зверненні в кеш. Антонім <a href="#miss">промаху</a>.</p>
				<p><a name="miss"></a><b>miss, промах</b> - ситуація не знаходження потрібної інформації при зверненні в кеш. Антонім <a href="#hit">попадання</a>. Якщо поточний рівень кеша не останній - далі відбувається звернення до наступного, інакше - до пам'яті. Повернені звідти дані віддаються ініціатору звернення і заповнюють (fill) поточний рівень кеша, витісняючи (evict) з обраного <a href="set">набору</a> стару, найменш потрібну інформацію - причому якщо вона поки більше ніде не записана, то її треба зберегти в наступному рівні. Майже всі кеші є неблокуємими (non-blocking), тобто продовжують приймати запити, поки обробляються промахи. Число утримуваних промахів визначається розміром спеціального <a href="#buffer">буфера</a>, при заповненні якого кеш блокує обробку запитів.</p>
				<p><a name="line"></a><b>line, строка</b> - основна одиниця ємності кеша розміром 32-128 байт. Обмін даними між різними рівнями кеша і між кешем і пам'яттю майже завжди відбувається цілими рядками.</p>
				<p><a name="associativity"></a><b>associativity, асоціативність</b> - індексованість ні адресою, а вмістом. Для складально-асоціативного <a href="#cache">кеша</a> і <a href="TLB">TLB</a> асоціативність це показник числа <a href="#way">шляхів</a>. За інших рівних, кеш/TLB з більшою асоціативністю має меншу частоту <a href="#miss">промахів</a>, але великі площі <a href="#tag">тегів</a>, споживання енергії (на байт) і (іноді) затримку. Повна асоціативність означає, що кеш/TLB складається з єдиного <a href="#set">набору</a> (це також може бути застосовано до <a href="#buffer">буферу</a>). Може приймати значення, не рівні цілої ступеня двійки. Кеш з асоціативністю 1 також називається кешем з прямим відображенням (direct-mapped).</p>
				<p><a name="way"></a><b>way, шлях</b> - сукупність всіх <a href="#line">рядків</a> <a href="#associativity">набірний-асоціативного</a> кеша з однаковим номером у всіх <a href="#set">наборах</a>.</p>
				<p><a name="set"></a><b>set, набір</b> - сукупність з N <a href="#line">рядків</a> кеша, одночасно здійснюється перевірка на наявність потрібних даних при зверненні, де N - показник <a href="#associativity">асоціативності</a>. При <a href="#miss">промаху</a> одна з рядків набору (як правило, з найменшою популярністю) заміняться новою інформацією.</p>
				<p><a name="port"></a><b>port, порт</b> - для кеша: інтерфейс між кешем і його контролером, керуючим обміном даних. Справжня N-портова структура дозволяє одночасно здійснювати N звернень за різними адресами, однак це вимагає великих витрат транзисторів і застосовується тільки в <a href="#RF">РФ</a>. Для кешу використовується більш проста псевдомногопортова схема: кеш ділиться на кілька <a href="#bank">банків</a>, кожен з яких працює незалежно, але обслуговує лише свою частину адрес. Як правило, 2-портовому <a href="#L1D">L1D</a> для мінімізації адресних конфліктів між портами досить 8 банків.</p>
				<p><a name="bank"></a><b>bank, банк</b> - частина кешу, організована як окремий 1- або 2-<a href="#cache-port">портовий</a> кеш, обслуговуючий частину адрес. Многобанкова схема використовується для створення псевдомногопортового кеша.</p>
				<p><a name="tag"></a><b>tag («мітка»), тег</b> - допоміжне слово, що зберігає адресу записаної в <a href="#line">рядку</a> кеша інформації, стан рядка (згідно <a href="#coherency">протоколу когерентності</a>) і її популярність (використовується при витісненні старих даних новими після <a href="#miss">промаху</a>). Фізично всі теги кеша зберігаються в окремому масиві і зчитуються або одночасно з вибіркою <a href="#set">набору</a> кешу, або (для економії енергії на шкоду швидкості) до вибірки. <a href="#cache-port">N-портовий</a> кеш має N-портовий масив тегів N 1-портових масивів з однаковим вмістом.</p>
				<p><a name="TLB"></a><b>TLB (translation look-aside buffer: буфер-шпаргалка для трансляції)</b> - кеш дескрипторів сторінок <a href="#VM">віртуальної пам'яті</a>, який замінює трансляцію <a href="#VA">віртуальних адрес</a> в <a href="#">фізичні</a> швидшим зчитуванням. Звернення в TLB потрібно для звернення в фізично адресуємий кеш (найчастіше - <a href="#L1">L1</a>) і відбувається або одночасно з читанням <a href="#tag">тегів</a> і вибіркою <a href="#set">набору</a> цього кешу, або (рідше) - до. При <a href="#hit">попаданні</a> в TLB отримана фізична адреса використовується для перевірки наявності потрібної інформації в обраному тезі кеша. Часто кілька TLB організовуються в ієрархію: TLB L1I і TLB L1D обслуговують запити до кешу <a href="#L1I">L1I</a> і <a href="#L1D">L1D</a>, при <a href="#miss">промаху</a> звертаються у <a href="#inclusive">вмикаємий(і)</a> TLB <a href="#L2">L2</a> більшого розміру (загальний TLB L2 або окремі TLB L2I і TLB L2D), а при промаху в ньому (них) віртуальний адресу надходить в <a href="#PMH">PMH</a>. TLB L2 не обслуговують кеш L2, а тільки промахи в TLB L1: трансляція адрес потрібна тільки для доступу до кешу L1, а при промаху в них звертаються інші кеші і пам'ять використовують як уже готову фізичну адресу. Часто TLB ділиться на кілька масивів: найбільший - для сторінок по 4 КБ, менші - для сторінок по 2/4 МБ і 1 ГБ (може зовсім бути відсутніми). TLB L1 часто <a href="#associativity">повноасоціативні</a>. <a href="#cache-port">N-портовому</a> кешу потрібно N-портовий TLB або N 1-портових TLB з однаковим вмістом.</p>
				<p><a name="PMH"></a><b>PMH (page miss handler: обробник промахів сторінок)</b> - транслятор <a href="#VA">віртуальних адрес</a> в <a href="#PA">фізичні</a>, також перевіряючий і права доступу. Активується при промаху в <a href="#TLB">TLB</a> останнього рівня, читає з кешу або пам'яті дескриптор потрібної сторінки, оновлює їм TLB і повертає фізичну адресу для звернення в кеш. Включає власний невеликий <a href="#buffer">буфер</a> і <a href="#prefetch">предзавантажник</a>.</p>
				<p><a name="LSU"></a><b>LSU (load-store unit: блок завантаження-збереження), MEU (memory unit: блок пам'яті)</b> - блок інтерфейсу між <a href="#back-end">тилом</a> конвеєра і <a href="#L1D">L1D</a>. Містить <a href="#queue">черги</a> читань і записів з відстеженням їх залежностей і функціями <a href="#WC">злиття записів</a>, <a href="#STLF">STLF</a> і <a href="#MD">позачергово доступу</a>. Іноді неточно називається MOB (memory order buffer, «буфер порядку» [записів в] пам'ять), маючи на увазі чергу програмного порядку записів - частина LSU, аналогічну <a href="#ROB">ROB</a> для <a href="#scheduler">планувальника</a>.</p>
				<p><a name="STLF"></a><b>STLF (store-to-load forwarding: перенаправлення збереження до завантаження)</b> - функція <a href="#queue">черги</a> записи в <a href="#LSU">LSU</a>, що дозволяє негайно виконати читання (підставивши дані з черги замість доступу до кешу) в разі збігу адреси читання з адресою міститься в черзі попереднього запису. Черга продовжує зберігати дані і після запису, тому STLF спрацьовує незалежно від факту вчинення запису читаємих даних.</p>
				<p><a name="MD"></a><b>MD (memory disambiguation: усунення невизначеності пам'яті), позачерговий доступ</b> - один з видів <a href="#speculative">попередження даних</a>, механізм <a href="#OoO">позачергово</a> доступу до кешу, який реалізується в <a href="#LSU">LSU</a>. Дозволяє переставляти порядок запитів, не порушуючи цілісність даних. Включає блок передбачення конфліктів адрес, аналогічний <a href="#BPU">провіснику переходів</a> і пророкує накладення адрес - при прогнозі відсутності конфлікту читання виповнюється до попереднього в програмному порядку запису, навіть якщо адреса останнього поки не відома. При накладенні адреси вже виконаного читання <a href="#scheduler">планувальник</a> анулює результати використовувавших його мопів і перезапускає їх з вірними (перепрочитаними) даними.</p>
				<p><a name="flush"></a><b>flush (змив)</b> - процес збереження всього (поки не збереженого) вмісту кеша даного рівня в наступному рівні ієрархії. Відбувається перед відключенням кеша або при зміні в таблицях <a href="#VA">трансляції</a> адрес.</p>
				<p><a name="fetch"></a><b>fetch (достать, принести)</b> - операція завантаження з <a href="#L1">L1</a>. Як правило, вказується з приставкою I для команд (з L1I) або D для даних (з L1D).</p>
				<p><a name="prefetch"></a><b>prefetch («пред-доставка»), префетч, предзавантаження</b> - операція попереднього читання даних за <a href="#speculative">попереджувальною</a> (передбаченою) адресою. Успішне предзавантаження приховує <a href="#latency">затримку</a> ієрархії кешів і пам'яті. Підключений до кешу предзавантажувач (prefetcher) відстежує адреси читань, записів і породивших їх команд, пророкує (на базі накопиченої статистики) наступні адреси ймовірно потрібних даних і перевіряє їх наявність в кеші. При <a href="#miss">промаху</a> запускається читання даних з кеша наступного рівня. При <a href="#hit">попаданні</a> деякі типи предзавантажників читають ці дані або у власний <a href="#buffer">буфер</a>, швидко їх видає, якщо буде зроблений запит з поєднаною адресою, або в чергу читання в <a href="#LSU">LSU</a>.</p>
				<p>Складний предзавантажник, як і <a href="#BPU">провісник переходів</a>, застосовує різні алгоритми і відстежує власну ефективність, відключаючи предзавантажники для труднопередбачених звернень щоб уникнути переміщення в кеш непотрібних даних ( «забруднення кешу»). Для боротьби з останнім відсутні в кеші і підвантажені ззовні дані або спочатку зберігаються в буфері предзавантажників і тільки в разі затребуваності пізніше записуються в кеш, або записуються відразу, але с зазначенням найменшою популярністю. Сучасні ЦП мають апаратне предзавантаження майже в усі кеші, а в їх <a href="#ISA">ISA</a> є команди програмного предзавантаження по явно вказаній адресі.</p>
				<p><a name="align"></a><b>align, вирівняти</b> - щодо розміщення в пам'яті багатобайтові інформації за адресою, без остачі, що поділяється на її розмір, рівний цілій степені двійки. У <a href="#CISC">CISC</a>-ЦП команди мають змінний розмір і рідко вирівнюються. Дані для будь-яких процесорів вирівнюються майже завжди, хоча лише для деяких <a href="#RISC">RISC</a>-<a href="#ISA">архітектур</a> це обов'язково. Вирівнювання прискорює доступ, виключаючи перетин <a href="#line">рядка</a> кеша, при якому потрібно прочитати наступний рядок і злити дві частини в одне <a href="#word">слово</a>.</p>
				<p><a name="unaligned"></a><b>unaligned, misaligned, невирявнаний</b> - щодо даних, до яких не застосовано <a href="#align">вирівнювання</a>. Деякі <a href="#x86">x86</a>-ЦП забороняють доступ до невирівняних даних для деяких <a href="#SIMD">векторних</a> команд. У деяких інших <a href="#ISA">архітектурах</a> невирівняний доступ заборонений повністю.</p>
				<p><a name="inclusive"></a><b>inclusive, інклюзивна, включаюча</b> - політика роботи кеша, в якому завжди зберігаються копії всіх кешей менших рівнів.</p>
				<p><a name="exclusive"></a><b>exclusive, ексклюзивна, виключаюча</b> - політика роботи кеша, в якому ніколи не зберігаються копії всіх кешей менших рівнів.</p>
				<p><a name="non-exclusive"></a><b>non-exclusive («невиключна»), mainly inclusive («в основному включаюча»), вільна</b> - комбінована політика роботи кеша, що допускає (необов'язкове) зберігання копій деяких рядків кешей менших рівнів.</p>
				<p><a name="WT"></a><b>WT (write-through), наскрізний запис</b> - проведення запису в кеш наступного рівня або пам'ять відразу після запису в даний рівень. Спрощує взаємодію кешей (при великому темпі записів і відсутності <a href="#WCB">WCB</a> - на шкоду продуктивності).</p>
				<p><a name="WB"></a><b>WB (write-back: «зворотний запис»), відкладений запис</b> - проведення запису в кеш наступного рівня або пам'ять багато пізніше запису в даний рівень (наприклад, при витісненні цього рядка при <a href="#miss">промаху</a>). Ускладнює взаємодію кешей, але дозволяє здійснити <a href="#WC">злиття записів</a>. Не плутати з <a href="#WB">однойменною</a> стадією конвеєра.</p>
				<p><a name="WC"></a><b>WC (write combine: злиття запису)</b> - операція заміни декількох записів за однаковою адресою останньої з цих записів і/або заміни декількох записів по послідовним адресам одним записом сукупної довжини. Виконується в черзі запису <a href="#LSU">LSU</a> і окремому <a href="#WCB">WCB</a>, збільшуючи продуктивність при великому темпі записів.</p>
				<p><a name="WCB"></a><b>WCB (write combine buffer: буфер злиття запису)</b> — <a href="#buffer">буфер</a> для <a href="#WC">злиття записів</a>, найчастіше — з <a href="#L1D">L1D</a> в <a href="#L2">L2</a>.</p>
				<p><a name="coherency"></a><b>coherency, когерентність</b> - узгодження вмісту кешів в многоядерній і/або многопроцесорній системі за допомогою протоколу когерентності. Різні протоколи описують 4-5 станів <a href="#line">рядка</a> кеша, що визначають дії при її локальних і віддалених читаннях і записах, а також (за першими літерами станів) назва самого протоколу (найчастіше - MESI, MOESI і MESIF). З числом ядер зростає складність дотримання когерентності і синхронізування її <a href="#snoop">снуп</a>-трафік.</p>
				<p><a name="snoop"></a><b>snoop (підглядання), cнуп</b> - перевірка стану рядку з даними адресою в кеші іншого ядра (щодо ініціатора перевірки). Використовується для реалізації <a href="#coherency">когерентності</a>. У багатопроцесорних системах cнуп-запити можуть займати значну частку всього міжпроцессорного трафіку, помітно знижуючи продуктивність.</p>
				<p><a name="buffer"></a><b>buffer, буфер</b> - загальна назва структури, що розділяє потік даних (в т.ч. між стадіями <a href="#pipline">конвеєра</a>). Якщо буфер містить більше одного <a href="#word">слова</a>, то оформлений у вигляді <a href="#queue">черги</a> або <a href="#associativity">повноасоціативної</a> пам'яті і в такому вигляді дозволяє згладжувати нерівномірність надходження потоку даних щодо його прийому.</p>
				<p><a name="queue"></a><b>queue, черга</b> - <a href="#buffer">буфер</a>, який працює за принципом <a href="#FIFO">FIFO</a>.</p>
				<p><a name="FIFO"></a><b>FIFO (first-in, first-out: першим прийшов, першим вийшов)</b> - принцип роботи <a href="#buffer">буфера</a>, при якому читання слів відбуваються в порядку їх запису.</p>
				<p><a name="IO"></a><b>IO, I/O (input-output), введення-виведення</b> - загальна назва операцій або блоків для обміну даннимімежду процесором і периферією.</p>
				<p><a name="BIU"></a><b>BIU (bus interface unit: блок шинного інтерфейсу)</b> - контролер шини між процесором і північним мостом чіпсета або міжпроцесорної шини.</p>
				<p><a name="DDR"></a><b>DDR (double data rate: подвійний темп даних)</b> - метод подвоєння <a href="#throughput">ПС</a> шини передачею двох <a href="#word">слів</a> за такт - на фронті і спаді тактового імпульсу.</p>
				<p><a name="QDR"></a><b>QDR (quad data rate: четверний темп даних)</b> - метод почетверіння <a href="#throughput">ПС</a> шини передачею чотирьох <a href="#word">слів</a> за такт - на фронтах і спадах тактових імпульсів двох ліній тактування, причому друга зміщена по фазі щодо першої на 90 ° (тобто на половину тривалості імпульсу).</p>
				<p><a name="MT"></a><b>МT/s (megatransfers/second: «мегапередачі/секунду»), МП/с (мільйони передач в секунду), GT/s (gigatransfers/second: «гігапередачі/секунду»), ГП/с (мільярди передач в секунду)</b> - питомий темп передачі, міра продуктивності шини зі змінною розрядністю. Дорівнює добутку частоти, числа переданих кожною смугою бітів/такт (1, 2 або 4), числа напрямків (1 для напівдуплексної шини, 2 для повнодуплексної) і щільності фізичного кодування (як правило, 1 для полудуплексної шини і 0,8 для повнодуплексної) . Для обчислення <a href="#throughput">ПС</a> шини (в бітах/с) слід помножити темп передачі на число бітових смуг в кожному напрямку (1-40, зазвичай вказується після назви шини і символу «x»).</p>
				<p><a name="FSB"></a><b>FSB (front-side bus: «фронтова шина»)</b> - загальна назва шини від x86-ЦП до північного моста чіпсета. Найчастіше напівдуплексною (з перемиканням напрямку передачею).</p>
				<p><a name="QPI"></a><b>QPI (QuickPath Interconnect)</b> - повнодуплексна (двунаправлена) міжпроцесорна шина для ЦП Intel.</p>
				<p><a name="HT"></a><b>HT (HyperTransport)</b> - повнодуплексна (двунаправлена) міжпроцессорная і чіпсетна шина для ЦП AMD.</p>
				<p><a name="processor"></a><b>DMI (Direct Media Interface)</b> - повнодуплексна (двунаправлена) шина від більшості сучасних ЦП Intel з <a href="#IMC">ІКП</a> до південного моста. Перш, до інтеграції функціональності північного моста в процесор, пов'язувала північний і південний мости чіпсета.</p>
				<p><a name="IMC"></a><b>IMC (integrated memory controller), ІКП, інтегрований (вбудований) контролер пам'яті</b> — контролер пам'яті, вбудований в процесор. Вбудовування покращує таймінги доступу.</p>
				<p><a name="parity"></a><b>parity, парність</b> - простий спосіб виявлення 1-бітових помилок. Застосовується для захисту від помилок читання інформації низької важливості, або при низькій частоті виникнення помилок, або при можливості простого відновлення <a href="#word">слова</a> з зовнішнього джерела. Застосовується для кеша <a href="#L1I">L1I</a> і, іноді, <a href="#L1D">L1D</a>, а також деяких шин. Як правило, вимагає 1 біт парності на кожні 8-32 біта даних.</p>
				<p><a name="ECC"></a><b>ECC (error correction code), код корекції помилок</b> - в процесорі і пам'яті: спосіб виявлення і корекції помилок. Вимагає більше часу і енергії для генерації і перевірки, ніж <a href="#parity">парність</a>. В ЦП використовується у всіх кешах, крім <a href="#L1I">L1I</a> і, зрідка, <a href="#L1D">L1D</a>. Найчастіше застосовується у вигляді коду Хеммінга для 8-байтових <a href="#word">слів</a>, займаючи додатковий ECC-байт на слово і даючи можливість виявлення 2-бітових помилок і корекції 1-бітних.</p>
				<h3><a name="7"></a>Фізична реалізація</h3>
				<p><a name="chip"></a><b>chip, чіп, мікросхема</b> - інтегральний напівпровідниковий прилад, який замінює тисячі і мільйони окремих (дискретних) елементів. Складається з корпусу і одного або декількох розміщених всередині <a href="#die">кристалів</a>. Найчастіше розміщується на друкованій платі - монтується припаюванням або вставляється в роз'єм. Мікросхеми є головними і найскладнішими частинами майже всіх електронних приладів. Більшість мікросхем - цифрові.</p>
				<p><a name="socket"></a><b>socket, роз'єм</b> - фіізичний і електричний інтерфейс для установки мікросхеми на друковану плату з можливістю швидкої заміни. Як правило, називається по типу відповідного для нього корпусу і числа виводів. Часто має фізичний захист від невірної установки. При вірній установці мікросхеми особлива деталь («ключ») в одному з її кутів повинна збігтися з ключем на роз'ємі.</p>
				<p><a name="BGA"></a><b>BGA (ball grid array: сітковий масив куль)</b> - корпус мікросхеми з масивом виводів на нижньому боці у вигляді кульок припою. Як правило, використовується для припаювання на плату.</p>
				<p><a name="LGA"></a><b>LGA (land grid array: сітковий масив майданчиків)</b> - корпус мікросхеми з масивом виводів на нижньому боці у вигляді контактних майданчиків. Підходить тільки для установки в <a href="#socket">роз'єм.</a></p>
				<p><a name="PGA"></a><b>PGA (pin grid array: сітковий масив штирів)</b> - корпус мікросхеми з масивом виводів на нижньому боці у вигляді штирів. Підходить для монтажу і установки в <a href="#socket">роз'єм</a>.</p>
				<p><a name="die"></a><b>die («кубик»), кристал</b> - головна частина мікросхеми, тонкий прямокутний кремнієвий кристал, на поверхні якого розташована велика безліч інтегральних елементів (найчастіше <a href="#MOS">транзисторів</a>) і <a href="#interconnect">міжз'єднань</a>. Розташований в корпусі, з яким сполучений найчастіше за принципом <a href="#FC">FC</a>-<a href="#BGA">BGA</a>-монтажу. Іноді застосовується безкорпусний монтаж кристала на друковану плату, скло або гнучку підкладку. Чим більше площа кристала (і їх число - для <a href="#MCM">MCM</a>), тим дорожче мікросхема. При виробництві кристали виходять після розрізання кремнієвої <a href="#wafer">пластини</a>.</p>
				<p><a name="wafer"></a><b>wafer («вафля»), пластина</b> - кругла кремнієва пластина діаметром до 300 мм, що використовується на мікроелектронній фабриці для виробництва мікросхем. На пластині формується регулярний масив «клітин», які після розрізання пластини утворюють <a href="#die">кристали</a>, що встановлюються в корпуси.</p>
				<p><a name="MCM"></a><b>MCM (multi-chip module: багаточіповий модуль)</b> — мікросхема, в корпус якої встановлено кілька <a href="#die">кристалів</a>: як правило, один на одному, рідше (для <a href="#TDP">сильнонагрітих</a> кристалів) - на одному рівні. Кристали можуть бути підключені не тільки до виводів, але і безпосередньо один до одного. MCM найчастіше застосовується для мікросхем пам'яті і <a href="#SoC">SoC</a>, рідше - для <a href="#core">багатоядерних</a> ЦП.</p>
				<p><a name="TSV"></a><b>TSV (through silicon vias: «скрізькремнієві отвори»)</b> - перспективний метод з'єднання <a href="#MCM">декількох кристалів</a> мікросхеми, що встановлюються одна на одну. Кристал з TSV має додаткові контакти на тильній стороні для наступного кристала. Без використання TSV кристали повинні встановлюватися із зсувом, щоб не затінювати контакти один одного; при цьому число самих контактів обмежено, так як вони можуть бути розташовані вздовж однієї або двох сторін кристала.</p>
				<p><a name="FC"></a><b>FC (flip-chip: перевернутий кристал)</b> - метод установки <a href="#die">кристала</a> в корпус транзисторами і контактами «вниз» (до плати). Застосовується в більшості сучасних мікросхем, але без використання <a href="#TSV">TSV</a> не дає можливість встановити в <a href="#MCM">MCM</a> кілька кристалів один на одного.</p>
				<p><a name="family"></a><b>family, сімейство</b> - для x86-ЦП: сукупність <a href="#model">моделей</a> із загальною <a href="#microarchitecture">мікроархітектурою</a> або декількома схожими. У відповіді на команду <a href="#CPUID">CPUID</a> позначається однією або двома шістандцятирічними цифрами.</p>
				<p><a name="model"></a><b>model, модель</b> - для x86-ЦП: лінійка процесорів з дещо відмінними деталями <a href="#microarchitecture">мікроархітектури</a> і різним числом <a href="#core">ядер</a>, розмірів <a href="#cache">кешей</a>, <a href="#PT">техпроцесом</a> і іншими характеристиками, що впливають на площу і пристрій <a href="#die">кристала</a>. У відповіді на команду <a href="#CPUID">CPUID</a> позначається однією або двома шістандцятирічними цифрами.</p>
				<p><a name="stepping"></a><b>stepping, степінг</b> - для x86-ЦП: модифікація <a href="#model">моделі</a>, зроблена для поліпшення другорядних численних споживчих характеристик щодо попереднього степпинга (наприклад, збільшення частоти шини). У відповіді на команду <a href="#CPUID">CPUID</a> позначається шестнадцатиричной цифрою.</p>
				<p><a name="revision"></a><b>revision, ревізія</b>- версія <a href="#chip">мікросхеми</a>, зроблена для поліпшення виробничих показників щодо попередньої ревізії (наприклад, зниження собівартості <a href="#die">кристала</a> і виправлення помилок). У відповіді на команду <a href="#CPUID">CPUID</a> позначається латинською буквою і десяткової цифрою. Перша ревізія (A0), як правило, є <a href="#ES">інженерним зразком</a>. Для ЦП AMD ревізія або дається як 4-символьний комбінація, або не вказується і вважається рівною степпінгу.</p>
				<p><a name="ES"></a><b>ES (engineering sample), інженерний зразок</b> - «бета-версія» мікросхеми, що не призначена для масового виробництва. Виготовляється малими партіями для налагодження і тестування. Іноді містить недокументовані режими або функції, недоступні в масових моделях.</p>
				<p><a name="MOS"></a><b>MOS (metal-oxide-semiconductor: метал-оксид-напівпровідник), МОП</b> - шарувата структура, що лежить в основі інтегральних польових транзисторів для перших <a href="#chip">мікросхем</a>. У сучасних чіпах керуючий затвор робиться з полікремнію (полікристалічного кремнію), але в найбільш просунутих знову застосовується <a href="#metal-gate">металевий затвор</a>. Подзатворний діелектрик також виготовляється не з діоксиду кремнію, а <a href="#high-k">high-k</a>-матеріалів. Частина <a href="#die">кристала</a>, утворює канал з керованою провідністю між витоком і стоком, в сучасних мікросхемах має <a href="#strained-silicon">механічні напруження</a>. Ідеальний МОП-транзистор має квадратичну залежність споживання енергії від напруги живлення і лінійну від частоти, причому максимум частоти лінійно залежить від напруги.</p>
				<figure class="middle"><img src="../img/90nm.png" ></figure>
				<p><a name="process-technology"></a><b>process technology, техпроцесс</b> - технологічний процес для масового виробництва мікросхем. Характеризується <a href="#CD">технормою</a>, числом шарів <a href="#connect">міжз'єднань</a>, діаметром <a href="#wafer">пластин</a>, різними оптимізаціями під швидкість і/або енергоефективність та ін. На передових фабриках перехід на новий техпроцес відбувається приблизно кожні 2 роки.</p>
				<p><a name="CD"></a><b>CD (тут - critical dimension: критичний розмір), технорма</b> - головна характеристика <a href="#PT">техпроцесу</a>. Вимірюється в нанометрах (nm, нм; раніше - в мікронах). Номінально рівна мінімальному півкроку лінійно-регулярної структури на <a href="#die">кристалі</a>, з деякими припущеннями - подвоєною мінімальною довжиною затвора <a href="#MOS">транзистора</a> і мінімальною шириною <a href="#interconnect">доріжки</a>. Однак починаючи з 45 нм ці пропорції не дотримуються, тому технорма набуває все більш рекламне значення. Довжина і ширина всього транзистора в кілька разів перевищує технорму. Через особливості сучасних технологічних процесів при переході на наступний (технорма якого, як правило, в 1,4 рази менше поточного) площа транзистора і всього кристала зменшується не в 2 (1,4²), а в 1,6-1,8 рази . Переведення мікросхеми на меншу технорму збільшує масовість її виробництва і максимальну частоту, а також зменшує собівартість і енергоспоживання. Устаткування для виробництва з меншою технормою значно дорожче.</p>
				<p><a name="CMOS"></a><b>CMOS (complementary MOS: комплементарний МОП), КМОП</b> - спочатку: вид логіки для цифрових мікросхем, що використовує в логічних вентилях пари p- і n-канальних МОН-транзисторів. У порівнянні з іншими схемами такий вентиль займає більше місця і має меншу граничну частоту, але споживає значно менше енергії. Застосовується в особливо енергоефективних схемах і рідко - в процесорах. Сьогодні під КМОП розуміється технологія для виготовлення мікросхем, що містять обидва види МОП-транзисторів, і використовується для всіх цифрових чіпів.</p>
				<p><a name="SRAM"></a><b>SRAM (static RAM: статичне ОЗП), СОЗП</b> - енергозалежна напівпровідникова пам'ять, яка використовується в мікросхемах в якості <a href="#cache">кешів</a>, <a href="#buffer">буферів</a> і <a href="#register">регістрів</a>. Серед інших видів пам'яті є найшвидшою, енергоспоживаючою і малощільною. Елементарна комірка СОЗП, що зберігає 1 біт, має 6 транзисторів для кешів <a href="#L2">L2</a> і <a href="#L3">L3</a>, 6 або 8 для <a href="#L1">L1</a> і 4 + 4W + R для <a href="#RF">РФ</a> з W <a href="#pipline-port">портами</a> запису і R портами читання.</p>
				<p><a name="MTp"></a><b>МТр (мільйонів транзисторів)</b> - авторська міра кількості транзисторів на <a href="#die">кристалі</a> або будь-якої його структурі.</p>
				<p><a name="interconnect"></a><b>interconnect, міжзв'язки, доріжки</b> - сукупність провідних каналів (доріжок), що з'єднують елементи мікросхеми один з одним, а також з її виводами. Розташовані на 5-12 рівнях, причому найнижчий (на рівні транзисторів) виготовлений з полікремнію, а решта - з міді (в старих чіпах - з алюмінію). Верхній шар має контактні площадки для з'єднання <a href="#die">кристала</a> з корпусом, наступний є силовим (поставляє живлення), що залишилося використовуються для синхронізації і перенесення даних. Електричні контакти між шарами і до транзисторів утворюються за допомогою металізованих отворів (vias). Міжшаровий діелектрик є <a href="#high-k">high-k</a>-з'єднанням.</p>
				<figure class="middle"><img src="../img/90nm-interconnect.png" ></figure>
				<p><a name="k"></a><b>k, діелектрична проникність</b> - безрозмірна фізична величина (часто звана діелектричною константою), що характеризує ізолюючі властивості. За визначенням, k (вакууму) = 1. До 2000 року в мікросхемах в якості діелектрика застосовувався діоксид кремнію (SiO<sub>2</sub>) з k = 3,9; матеріали з більшою k відносяться до класу <a href="#high-k">high-k</a>, з меншою - до <a href="#low-k">low-k</a>. У нових чіпах використовуються обидва види.</p>
				<p><a name="high-k"></a><b>high-k (висока «k»)</b> - відносно діелектриків з показником <a href="#k">k</a> більше, ніж у SiO<sub>2</sub>. Діелектрики на основі гафнію (HfSiO або HfSiON з k≈25) застосовуються замість SiO<sub>2</sub> між затвором і каналом <a href="MOS">МОП</a>-транзистора, зменшуючи струми витоку, викликані тунелюванням електронів через малу товщину шару - high-k-діелектрик дозволяє потовщити ізолятор без уповільнення транзистора.</p>
				<p><a name="low-k"></a><b>low-k (низька «k»)</b> - щодо діелектриків з показником <a href="#k">k</a> менше, ніж у SiO<sub>2</sub>. Легований вуглецем пористий SiO<sub>2</sub> (з k≤3) застосовується замість звичайного SiO<sub>2</sub> як міжшаровий ізолятор для <a href="#interconnect">міжз'єднань</a>, зменшуючи паразитну ємність. Це дозволяє прискорити схему і зменшити її споживання.</p>
				<p><a name="strained-silicon"></a><b>strained silicon, напружений кремній</b> - техніка прискорення перемикання <a href="#MOS">МОП</a>-транзисторів, що застосовується до області каналу: для p-канальних транзисторів застосовується стиснення кроку кристалічної решітки вздовж каналу, для n-канальних - розтягнення.</p>
				<p><a name="SOI"></a><b>SOI (silicon on insulator), кремній на ізоляторі, КНІ</b> - техніка зменшення струмів витоку за рахунок розміщення під усіма транзисторами <a href="#die">кристала</a> ізолюючого шару (як правило - діоксиду кремнію).</p>
				<p><a name="metal-gate"></a><b>metal gate, металевий затвор</b> - використання в якості затвора <a href="#MOS">МОП</a>-транзистора металлокремніевого з'єднання або сплаву металів замість полікремнію для прискорення і зменшення споживання енергії.</p>
				<p><a name="TDP"></a><b>TDP (thermal design power: потужність по термопроекту)</b> - максимальна тривала теплорозсіювача здатність, яка повинна забезпечити мікросхемі система охолодження (в т. ч. для мікросхем, які не потребують використання радіатора). Дорівнює практичному максимуму розсіюємої (виділяємої у вигляді тепла) потужності при стабільній роботі мікросхеми на штатних частотах і напругах і максимально допустимої власній температурі. Береться трохи нижче досяжного на спеціальних тестах теоретичного максимуму і при тривалому завантаженні перевищується лише на невеликі проміжки часу. Для цифрових мікросхем використовується як приблизний показник споживання енергії (майже 100% її розсіюється), проте для TDP <a href="#processor">процесорів</a> «округляється» вгору до одного зі стандартних значень (не обов'язково найближчого - в т. x. p маркетингових міркувань). TDP мікросхем, що вимагають наявність радіатора, як правило, вказується тільки для тепловиділення через верхню кришку, якою стосується радіатор, тобто без урахування тепла, що минає через друковану плату. В результаті TDP процесора може бути вище або нижче максимального тривалого споживання енергії. Сучасні ЦП мають програмоване значення TDP для підстроювання під використовувану систему охолодження.</p>
				<p><a name="V-plane"></a><b>V-plane (voltage plane: шар напруги)</b> - силова шина живлення мікросхеми. У найпростішому випадку є 1 шар харчування для всього кристала, але для складних мікросхем, включаючи процесори, з метою поліпшення енергоефективності живлення різних блоків може бути роздільним, щоб була можливість незалежного регулювання напруги живлення. У більшості <a href="#CPU">ЦП</a> є 2-4 регульовані шини і 1-3 фіксовані. Всі вони підключені до відповідних каналів блоку <a href="#VRM">VRM</a>.</p>
				<p><a name="VRM"></a><b>VRM (voltage regulator module: модуль-регулятор напруги)</b> - блок живлення для мікросхем, що поставляють напруги для їх <a href="#V-plane">силових шин</a>. Найчастіше розташовується на материнській платі. Кожен канал VRM є вольтододатковим перетворювачем, що знижує напругу від 5 або (частіше) 12 В (одержуваних з блоку живлення) до 0,5-3 В, причому ця величина може бути фіксованою, що настроюється при завантаженні системи або задається в реальному часі (в цьому випадку вона може змінюватися десятки разів в секунду). Більшість сучасних мікросхем вимагають 0,6-1,5 В. Найбільш складні з них (зокрема, майже всі <a href="#CPU">процесори</a>) повідомляють про всі необхідні в даний момент напруження з точністю 2,5 або 5 мВ через спеціальну послідовну шину, до якої підключений контролер VRM. Через неї ж VRM може повідомляти процесору про свої можливості, обмеження і поточний стан.</p>
				<p><a name="power-gate"></a><b>power gate (силовий затвор, ключ)</b> - комутатор (ключ) харчування. Зовнішній ключ, як правило, заснований на одному потужному транзисторі, а інтегрований в мікросхему - на безлічі слабкострумових. Інтегрований ключ управляє подачею живлення з будь-якої <a href="#V-plane">силової шини</a> або «землі» («мінус» харчування) на окремі блоки. Відключення простоюючих блоків зменшує загальне споживання.</p>
				<p><a name="C-state"></a><b>C-state [точна розшифровка невідома], енергостан</b> - стан мікросхеми з точки зору споживання енергії. Для кожної <a href="#V-plane">силової шини</a> описується його напруга, а для кожного блоку - стан <a href="#power-gate">ключа живлення</a> (якщо є), подача тактування і активність. Кожна допустима комбінація цих параметрів позначається буквою C і цифрою, причому C0 означає «все включено», а великі цифри позначають більш глибокий сон при простоювані і більший час для пробудження.</p>
				<p><a name="P-state"></a><b>P-state (performance state: стан продуктивності)</b> - видимий для ОС стан мікросхеми з точки зору балансу швидкості і споживання енергії в <a href="#C-state">енергостан</a> C0. Для кожної <a href="#V-plane">силової шини</a> описує його напругу, а кожного блоку - частоту тактування. Кожна така комбінація позначається окремою цифрою, причому P0 позначає максимальні швидкість і споживання, а великі цифри позначають їх поступове зменшення. Для ЦП Intel P1 означає <a href="#base-freq">штатну частоту</a>, а P0 - максимальну з урахуванням технології <a href="#Turbo-Boost">Turbo Boost</a>. Для ЦП AMD P0 означає максимальну можливу на даний момент частоту, мінливу при роботі аналогічною технологією <a href="#Turbo-Core">Turbo-Core</a>.</p>
				<p><a name="SpeedStep"></a><b>SpeedStep, Cool’n’Quiet, PowerNow!</b> - назва фірмових технологій енергозбереження для ЦП Intel, AMD і VIA.</p>
				<p><a name="base-freq"></a><b>base frequency (базова частота), штатна частота</b> - максимальна частота тривалої надійної роботи цифрової мікросхеми при повному навантаженні і максимальної допустимої температури кристала. Є однією з основних характеристик цифрової мікросхеми. Визначається під час пост-виробничого тесту разом з необхідними для її підтримки живлячими напругами. У роботі процесора частота може автоматично підвищуватися понад штатної при наявності технології <a href="#Turbo-Boost">авторозгону</a>. Ручне підвищення (звичайний розгін), як правило, не рекомендується, так як може призвести до перегріву і виходу з ладу чіпа.</p>
				<p><a name="Turbo-Boost"></a><b>Turbo Boost, Turbo Core</b> - назва фірмових технологій апаратного (програмно-незалежного) авторозгону (підвищення частоти понад <a href="#base-freq">штатної</a>) для ЦП Intel і AMD. Вбудований в ЦП контролер живлення враховує такі виміряні (або передбачені їм на основі раніше зроблених прямих або непрямих вимірів) параметри:</p>
				<ul class="ul"><li>число завантажених ядер або модулів;</li><li>середня і/або максимальна (по всіх датчиків) температура <a href="#die">кристала</a>;</li><li>сила струму для кожної <a href="#V-plane">силової шини</a>;</li><li>споживана потужність (сума добутків струму на напругу для кожної силової шини).</li></ul>
				<p>Якщо всі необхідні для авторозгону параметри не перевищують допустимі для даного ЦП межі, то контролер збільшує <a href="#PLL">множник частоти</a> (і, можливо, напругу на відповідній шині) повністю завантаженим ядром (іноді разом з деякими простоюючими, але не відключаємими), поки будь-який з параметрів не досягне межі. Просунуті версії авторозгону можуть привести до виділення процесором енергії понад значення <a href="#TDP">TDP</a> на час до хвилини, поки інші параметри (насамперед температура) не дійшли насичення.</p>
				<p><a name="frequency-ceiling"></a><b>frequency ceiling, частотна стеля</b> - максимально досяжна на даний момент <a href="#base-freq">штатна частота</a> мікросхем даного типу при масовому виробництві на даному обладнанні. Збільшується при переході на менший <a href="#PT">техпроцес</a>, наступний <a href="#stepping">степінг</a> і іншу <a href="#microarchitecture">мікроархитектуру</a> з «простими» (за <a href="#FO4">метрикою FO4</a>) стадіями <a href="#pipline">конвеєра</a> (для нового ЦП).</p>
				<p><a name="FO4"></a><b>FO4 (fan-out of 4: коефіцієнт розгалуження 4)</b> - відносна метрика часу спрацьовування логічної схеми, яка не залежить від використовуваного <a href="#PT">техпроцесу</a> (на відміну від абсолютної, вимірюваної в частках секунди). Дорівнює часу спрацьовування логічного вентиля, навантаженого на виході чотирма іншими того ж розміру. У процесорах застосовується для вимірювання логічної складності стадії <a href="#pipline">конвеєра</a>. Типове її значення для сучасних x86-ЦП - 21-23 одиниці FO4. Конвеєр, розділений на більше число стадій меншої складності, зможе працювати на більшій частоті, виконуючи ту ж сукупну роботу, так як кожній стадії потрібний менший час для спрацьовування. Реальна робота в стадії менше, так як при вимірі «повної FO4-еквівалентної» затримки враховується тремтіння частоти (джиттер) і нечіткі зрізи сигналу тактування (≈2 FO4), а також затримки міжстадійних <a href="#buffer">буферів даних (≈3 FO4).</a>
				</div>	  
			</main>
			<footer class="footer"><div>© 2017 Боровик М.В.</div></footer>
		</div>
		<a href="#" class="scrollup">Scroll</a> 
	</body>
	</html>